# This file was generated. Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"affiliation\""
type Affiliation {
    "An object relationship"
    group: Group!
    groupId: String!
    groupRole: String!
    id: String!
    "An object relationship"
    user: User!
    userId: String!
}

"aggregated selection of \"affiliation\""
type AffiliationAggregate {
    aggregate: AffiliationAggregateFields
    nodes: [Affiliation!]!
}

"aggregate fields of \"affiliation\""
type AffiliationAggregateFields {
    count(columns: [AffiliationSelectColumn!], distinct: Boolean): Int!
    max: AffiliationMaxFields
    min: AffiliationMinFields
}

"aggregate max on columns"
type AffiliationMaxFields {
    groupId: String
    groupRole: String
    id: String
    userId: String
}

"aggregate min on columns"
type AffiliationMinFields {
    groupId: String
    groupRole: String
    id: String
    userId: String
}

"response of any mutation on the table \"affiliation\""
type AffiliationMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [Affiliation!]!
}

"columns and relationships of \"application\""
type Application {
    "An array relationship"
    groupApplications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "An aggregate relationship"
    groupApplicationsAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    id: String!
    name: String!
    topUrl: String!
    validFlag: Boolean
}

"aggregated selection of \"application\""
type ApplicationAggregate {
    aggregate: ApplicationAggregateFields
    nodes: [Application!]!
}

"aggregate fields of \"application\""
type ApplicationAggregateFields {
    count(columns: [ApplicationSelectColumn!], distinct: Boolean): Int!
    max: ApplicationMaxFields
    min: ApplicationMinFields
}

"aggregate max on columns"
type ApplicationMaxFields {
    id: String
    name: String
    topUrl: String
}

"aggregate min on columns"
type ApplicationMinFields {
    id: String
    name: String
    topUrl: String
}

"columns and relationships of \"group\""
type Group {
    "An array relationship"
    accounts(
        "distinct select on columns"
        distinctOn: [HouseholdAccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAccountOrderBy!],
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): [HouseholdAccount!]!
    "An aggregate relationship"
    accountsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdAccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAccountOrderBy!],
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): HouseholdAccountAggregate!
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An aggregate relationship"
    affiliationsAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "An array relationship"
    categories(
        "distinct select on columns"
        distinctOn: [HouseholdCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdCategoryBoolExp
    ): [HouseholdCategory!]!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "An array relationship"
    creditCardSummaries(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): [HouseholdCreditCardSummary!]!
    "An aggregate relationship"
    creditCardSummariesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): HouseholdCreditCardSummaryAggregate!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    "An array relationship"
    depositCategories(
        "distinct select on columns"
        distinctOn: [HouseholdDepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDepositCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): [HouseholdDepositCategory!]!
    "An aggregate relationship"
    depositCategoriesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDepositCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): HouseholdDepositCategoryAggregate!
    "An array relationship"
    genres(
        "distinct select on columns"
        distinctOn: [HouseholdGenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdGenreOrderBy!],
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): [HouseholdGenre!]!
    "An aggregate relationship"
    genresAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdGenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdGenreOrderBy!],
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): HouseholdGenreAggregate!
    "An array relationship"
    groupApplications(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "An aggregate relationship"
    groupApplicationsAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    id: String!
    "An array relationship"
    importFileHistories(
        "distinct select on columns"
        distinctOn: [HouseholdImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): [HouseholdImportFileHistory!]!
    "An aggregate relationship"
    importFileHistoriesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): HouseholdImportFileHistoryAggregate!
    name: String!
    "An array relationship"
    summaryCategories(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): [HouseholdSummaryCategory!]!
    "An aggregate relationship"
    summaryCategoriesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): HouseholdSummaryCategoryAggregate!
    "An object relationship"
    transferCategory: HouseholdTransferCategory
}

"aggregated selection of \"group\""
type GroupAggregate {
    aggregate: GroupAggregateFields
    nodes: [Group!]!
}

"aggregate fields of \"group\""
type GroupAggregateFields {
    count(columns: [GroupSelectColumn!], distinct: Boolean): Int!
    max: GroupMaxFields
    min: GroupMinFields
}

"columns and relationships of \"group_application\""
type GroupApplication {
    "An object relationship"
    application: Application!
    applicationId: String!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
}

"aggregated selection of \"group_application\""
type GroupApplicationAggregate {
    aggregate: GroupApplicationAggregateFields
    nodes: [GroupApplication!]!
}

"aggregate fields of \"group_application\""
type GroupApplicationAggregateFields {
    count(columns: [GroupApplicationSelectColumn!], distinct: Boolean): Int!
    max: GroupApplicationMaxFields
    min: GroupApplicationMinFields
}

"aggregate max on columns"
type GroupApplicationMaxFields {
    applicationId: String
    groupId: String
    id: String
}

"aggregate min on columns"
type GroupApplicationMinFields {
    applicationId: String
    groupId: String
    id: String
}

"aggregate max on columns"
type GroupMaxFields {
    id: String
    name: String
}

"aggregate min on columns"
type GroupMinFields {
    id: String
    name: String
}

"columns and relationships of \"household.account\""
type HouseholdAccount {
    "An array relationship"
    allDetailViews(
        "distinct select on columns"
        distinctOn: [HouseholdAllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAllDetailViewOrderBy!],
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): [HouseholdAllDetailView!]!
    "An aggregate relationship"
    allDetailViewsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdAllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAllDetailViewOrderBy!],
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): HouseholdAllDetailViewAggregate!
    "An array relationship"
    creditCardSummaries(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): [HouseholdCreditCardSummary!]!
    "An aggregate relationship"
    creditCardSummariesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): HouseholdCreditCardSummaryAggregate!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    displayOrder: Int!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    name: String!
    validFlag: Boolean
}

"aggregated selection of \"household.account\""
type HouseholdAccountAggregate {
    aggregate: HouseholdAccountAggregateFields
    nodes: [HouseholdAccount!]!
}

"aggregate fields of \"household.account\""
type HouseholdAccountAggregateFields {
    avg: HouseholdAccountAvgFields
    count(columns: [HouseholdAccountSelectColumn!], distinct: Boolean): Int!
    max: HouseholdAccountMaxFields
    min: HouseholdAccountMinFields
    stddev: HouseholdAccountStddevFields
    stddevPop: HouseholdAccountStddevPopFields
    stddevSamp: HouseholdAccountStddevSampFields
    sum: HouseholdAccountSumFields
    varPop: HouseholdAccountVarPopFields
    varSamp: HouseholdAccountVarSampFields
    variance: HouseholdAccountVarianceFields
}

"aggregate avg on columns"
type HouseholdAccountAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type HouseholdAccountMaxFields {
    displayOrder: Int
    groupId: String
    id: String
    name: String
}

"aggregate min on columns"
type HouseholdAccountMinFields {
    displayOrder: Int
    groupId: String
    id: String
    name: String
}

"response of any mutation on the table \"household.account\""
type HouseholdAccountMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdAccount!]!
}

"aggregate stddev on columns"
type HouseholdAccountStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type HouseholdAccountStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type HouseholdAccountStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type HouseholdAccountSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type HouseholdAccountVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type HouseholdAccountVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type HouseholdAccountVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"household.all_detail_view\""
type HouseholdAllDetailView {
    accountId: String
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"aggregated selection of \"household.all_detail_view\""
type HouseholdAllDetailViewAggregate {
    aggregate: HouseholdAllDetailViewAggregateFields
    nodes: [HouseholdAllDetailView!]!
}

"aggregate fields of \"household.all_detail_view\""
type HouseholdAllDetailViewAggregateFields {
    avg: HouseholdAllDetailViewAvgFields
    count(columns: [HouseholdAllDetailViewSelectColumn!], distinct: Boolean): Int!
    max: HouseholdAllDetailViewMaxFields
    min: HouseholdAllDetailViewMinFields
    stddev: HouseholdAllDetailViewStddevFields
    stddevPop: HouseholdAllDetailViewStddevPopFields
    stddevSamp: HouseholdAllDetailViewStddevSampFields
    sum: HouseholdAllDetailViewSumFields
    varPop: HouseholdAllDetailViewVarPopFields
    varSamp: HouseholdAllDetailViewVarSampFields
    variance: HouseholdAllDetailViewVarianceFields
}

"aggregate avg on columns"
type HouseholdAllDetailViewAvgFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate max on columns"
type HouseholdAllDetailViewMaxFields {
    accountId: String
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"aggregate min on columns"
type HouseholdAllDetailViewMinFields {
    accountId: String
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"aggregate stddev on columns"
type HouseholdAllDetailViewStddevFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate stddevPop on columns"
type HouseholdAllDetailViewStddevPopFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate stddevSamp on columns"
type HouseholdAllDetailViewStddevSampFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate sum on columns"
type HouseholdAllDetailViewSumFields {
    originalAmount: numeric
    signedAmount: numeric
}

"aggregate varPop on columns"
type HouseholdAllDetailViewVarPopFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate varSamp on columns"
type HouseholdAllDetailViewVarSampFields {
    originalAmount: Float
    signedAmount: Float
}

"aggregate variance on columns"
type HouseholdAllDetailViewVarianceFields {
    originalAmount: Float
    signedAmount: Float
}

"columns and relationships of \"household.category\""
type HouseholdCategory {
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    "An object relationship"
    depositCategory: HouseholdDepositCategory
    displayOrder: Int!
    "An object relationship"
    genre: HouseholdGenre!
    genreId: String!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    name: String!
    "An array relationship"
    summaryCategories(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): [HouseholdSummaryCategory!]!
    "An aggregate relationship"
    summaryCategoriesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): HouseholdSummaryCategoryAggregate!
    "An array relationship"
    transferCategories(
        "distinct select on columns"
        distinctOn: [HouseholdTransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTransferCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): [HouseholdTransferCategory!]!
    "An aggregate relationship"
    transferCategoriesAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTransferCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): HouseholdTransferCategoryAggregate!
    validFlag: Boolean
}

"response of any mutation on the table \"household.category\""
type HouseholdCategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdCategory!]!
}

"columns and relationships of \"household.credit_card_detail\""
type HouseholdCreditCardDetail {
    amount: numeric!
    "An object relationship"
    category: HouseholdCategory!
    categoryId: String!
    "An object relationship"
    creditCardSummary: HouseholdCreditCardSummary!
    date: date!
    "An object relationship"
    genre: HouseholdGenre!
    genreId: String!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    iocomeType: String!
    memo: String
    summaryId: String!
    "An object relationship"
    user: User!
    userId: String!
}

"aggregated selection of \"household.credit_card_detail\""
type HouseholdCreditCardDetailAggregate {
    aggregate: HouseholdCreditCardDetailAggregateFields
    nodes: [HouseholdCreditCardDetail!]!
}

"aggregate fields of \"household.credit_card_detail\""
type HouseholdCreditCardDetailAggregateFields {
    avg: HouseholdCreditCardDetailAvgFields
    count(columns: [HouseholdCreditCardDetailSelectColumn!], distinct: Boolean): Int!
    max: HouseholdCreditCardDetailMaxFields
    min: HouseholdCreditCardDetailMinFields
    stddev: HouseholdCreditCardDetailStddevFields
    stddevPop: HouseholdCreditCardDetailStddevPopFields
    stddevSamp: HouseholdCreditCardDetailStddevSampFields
    sum: HouseholdCreditCardDetailSumFields
    varPop: HouseholdCreditCardDetailVarPopFields
    varSamp: HouseholdCreditCardDetailVarSampFields
    variance: HouseholdCreditCardDetailVarianceFields
}

"aggregate avg on columns"
type HouseholdCreditCardDetailAvgFields {
    amount: Float
}

"aggregate max on columns"
type HouseholdCreditCardDetailMaxFields {
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    summaryId: String
    userId: String
}

"aggregate min on columns"
type HouseholdCreditCardDetailMinFields {
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    summaryId: String
    userId: String
}

"response of any mutation on the table \"household.credit_card_detail\""
type HouseholdCreditCardDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdCreditCardDetail!]!
}

"aggregate stddev on columns"
type HouseholdCreditCardDetailStddevFields {
    amount: Float
}

"aggregate stddevPop on columns"
type HouseholdCreditCardDetailStddevPopFields {
    amount: Float
}

"aggregate stddevSamp on columns"
type HouseholdCreditCardDetailStddevSampFields {
    amount: Float
}

"aggregate sum on columns"
type HouseholdCreditCardDetailSumFields {
    amount: numeric
}

"aggregate varPop on columns"
type HouseholdCreditCardDetailVarPopFields {
    amount: Float
}

"aggregate varSamp on columns"
type HouseholdCreditCardDetailVarSampFields {
    amount: Float
}

"aggregate variance on columns"
type HouseholdCreditCardDetailVarianceFields {
    amount: Float
}

"columns and relationships of \"household.credit_card_summary\""
type HouseholdCreditCardSummary {
    "An object relationship"
    account: HouseholdAccount!
    accountId: String!
    count: Int!
    creditCard: String!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    totalAmount: numeric!
    withdrawalDate: date!
}

"aggregated selection of \"household.credit_card_summary\""
type HouseholdCreditCardSummaryAggregate {
    aggregate: HouseholdCreditCardSummaryAggregateFields
    nodes: [HouseholdCreditCardSummary!]!
}

"aggregate fields of \"household.credit_card_summary\""
type HouseholdCreditCardSummaryAggregateFields {
    avg: HouseholdCreditCardSummaryAvgFields
    count(columns: [HouseholdCreditCardSummarySelectColumn!], distinct: Boolean): Int!
    max: HouseholdCreditCardSummaryMaxFields
    min: HouseholdCreditCardSummaryMinFields
    stddev: HouseholdCreditCardSummaryStddevFields
    stddevPop: HouseholdCreditCardSummaryStddevPopFields
    stddevSamp: HouseholdCreditCardSummaryStddevSampFields
    sum: HouseholdCreditCardSummarySumFields
    varPop: HouseholdCreditCardSummaryVarPopFields
    varSamp: HouseholdCreditCardSummaryVarSampFields
    variance: HouseholdCreditCardSummaryVarianceFields
}

"aggregate avg on columns"
type HouseholdCreditCardSummaryAvgFields {
    count: Float
    totalAmount: Float
}

"aggregate max on columns"
type HouseholdCreditCardSummaryMaxFields {
    accountId: String
    count: Int
    creditCard: String
    groupId: String
    id: String
    totalAmount: numeric
    withdrawalDate: date
}

"aggregate min on columns"
type HouseholdCreditCardSummaryMinFields {
    accountId: String
    count: Int
    creditCard: String
    groupId: String
    id: String
    totalAmount: numeric
    withdrawalDate: date
}

"response of any mutation on the table \"household.credit_card_summary\""
type HouseholdCreditCardSummaryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdCreditCardSummary!]!
}

"aggregate stddev on columns"
type HouseholdCreditCardSummaryStddevFields {
    count: Float
    totalAmount: Float
}

"aggregate stddevPop on columns"
type HouseholdCreditCardSummaryStddevPopFields {
    count: Float
    totalAmount: Float
}

"aggregate stddevSamp on columns"
type HouseholdCreditCardSummaryStddevSampFields {
    count: Float
    totalAmount: Float
}

"aggregate sum on columns"
type HouseholdCreditCardSummarySumFields {
    count: Int
    totalAmount: numeric
}

"columns and relationships of \"household.credit_card_summary_total_by_account_view\""
type HouseholdCreditCardSummaryTotalByAccountView {
    accountId: String
    date: date
    displayOrder: Int
    groupId: String
    iocomeType: String
    name: String
    total: numeric
}

"aggregated selection of \"household.credit_card_summary_total_by_account_view\""
type HouseholdCreditCardSummaryTotalByAccountViewAggregate {
    aggregate: HouseholdCreditCardSummaryTotalByAccountViewAggregateFields
    nodes: [HouseholdCreditCardSummaryTotalByAccountView!]!
}

"aggregate fields of \"household.credit_card_summary_total_by_account_view\""
type HouseholdCreditCardSummaryTotalByAccountViewAggregateFields {
    avg: HouseholdCreditCardSummaryTotalByAccountViewAvgFields
    count(columns: [HouseholdCreditCardSummaryTotalByAccountViewSelectColumn!], distinct: Boolean): Int!
    max: HouseholdCreditCardSummaryTotalByAccountViewMaxFields
    min: HouseholdCreditCardSummaryTotalByAccountViewMinFields
    stddev: HouseholdCreditCardSummaryTotalByAccountViewStddevFields
    stddevPop: HouseholdCreditCardSummaryTotalByAccountViewStddevPopFields
    stddevSamp: HouseholdCreditCardSummaryTotalByAccountViewStddevSampFields
    sum: HouseholdCreditCardSummaryTotalByAccountViewSumFields
    varPop: HouseholdCreditCardSummaryTotalByAccountViewVarPopFields
    varSamp: HouseholdCreditCardSummaryTotalByAccountViewVarSampFields
    variance: HouseholdCreditCardSummaryTotalByAccountViewVarianceFields
}

"aggregate avg on columns"
type HouseholdCreditCardSummaryTotalByAccountViewAvgFields {
    displayOrder: Float
    total: Float
}

"aggregate max on columns"
type HouseholdCreditCardSummaryTotalByAccountViewMaxFields {
    accountId: String
    date: date
    displayOrder: Int
    groupId: String
    iocomeType: String
    name: String
    total: numeric
}

"aggregate min on columns"
type HouseholdCreditCardSummaryTotalByAccountViewMinFields {
    accountId: String
    date: date
    displayOrder: Int
    groupId: String
    iocomeType: String
    name: String
    total: numeric
}

"aggregate stddev on columns"
type HouseholdCreditCardSummaryTotalByAccountViewStddevFields {
    displayOrder: Float
    total: Float
}

"aggregate stddevPop on columns"
type HouseholdCreditCardSummaryTotalByAccountViewStddevPopFields {
    displayOrder: Float
    total: Float
}

"aggregate stddevSamp on columns"
type HouseholdCreditCardSummaryTotalByAccountViewStddevSampFields {
    displayOrder: Float
    total: Float
}

"aggregate sum on columns"
type HouseholdCreditCardSummaryTotalByAccountViewSumFields {
    displayOrder: Int
    total: numeric
}

"aggregate varPop on columns"
type HouseholdCreditCardSummaryTotalByAccountViewVarPopFields {
    displayOrder: Float
    total: Float
}

"aggregate varSamp on columns"
type HouseholdCreditCardSummaryTotalByAccountViewVarSampFields {
    displayOrder: Float
    total: Float
}

"aggregate variance on columns"
type HouseholdCreditCardSummaryTotalByAccountViewVarianceFields {
    displayOrder: Float
    total: Float
}

"aggregate varPop on columns"
type HouseholdCreditCardSummaryVarPopFields {
    count: Float
    totalAmount: Float
}

"aggregate varSamp on columns"
type HouseholdCreditCardSummaryVarSampFields {
    count: Float
    totalAmount: Float
}

"aggregate variance on columns"
type HouseholdCreditCardSummaryVarianceFields {
    count: Float
    totalAmount: Float
}

"columns and relationships of \"household.daily_detail\""
type HouseholdDailyDetail {
    "An object relationship"
    account: HouseholdAccount!
    accountId: String!
    amount: numeric!
    "An object relationship"
    category: HouseholdCategory!
    categoryId: String!
    date: date!
    "An object relationship"
    genre: HouseholdGenre!
    genreId: String!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    iocomeType: String!
    memo: String
    "An object relationship"
    user: User!
    userId: String!
}

"aggregated selection of \"household.daily_detail\""
type HouseholdDailyDetailAggregate {
    aggregate: HouseholdDailyDetailAggregateFields
    nodes: [HouseholdDailyDetail!]!
}

"aggregate fields of \"household.daily_detail\""
type HouseholdDailyDetailAggregateFields {
    avg: HouseholdDailyDetailAvgFields
    count(columns: [HouseholdDailyDetailSelectColumn!], distinct: Boolean): Int!
    max: HouseholdDailyDetailMaxFields
    min: HouseholdDailyDetailMinFields
    stddev: HouseholdDailyDetailStddevFields
    stddevPop: HouseholdDailyDetailStddevPopFields
    stddevSamp: HouseholdDailyDetailStddevSampFields
    sum: HouseholdDailyDetailSumFields
    varPop: HouseholdDailyDetailVarPopFields
    varSamp: HouseholdDailyDetailVarSampFields
    variance: HouseholdDailyDetailVarianceFields
}

"aggregate avg on columns"
type HouseholdDailyDetailAvgFields {
    amount: Float
}

"aggregate max on columns"
type HouseholdDailyDetailMaxFields {
    accountId: String
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    userId: String
}

"aggregate min on columns"
type HouseholdDailyDetailMinFields {
    accountId: String
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    userId: String
}

"response of any mutation on the table \"household.daily_detail\""
type HouseholdDailyDetailMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdDailyDetail!]!
}

"aggregate stddev on columns"
type HouseholdDailyDetailStddevFields {
    amount: Float
}

"aggregate stddevPop on columns"
type HouseholdDailyDetailStddevPopFields {
    amount: Float
}

"aggregate stddevSamp on columns"
type HouseholdDailyDetailStddevSampFields {
    amount: Float
}

"aggregate sum on columns"
type HouseholdDailyDetailSumFields {
    amount: numeric
}

"aggregate varPop on columns"
type HouseholdDailyDetailVarPopFields {
    amount: Float
}

"aggregate varSamp on columns"
type HouseholdDailyDetailVarSampFields {
    amount: Float
}

"aggregate variance on columns"
type HouseholdDailyDetailVarianceFields {
    amount: Float
}

"columns and relationships of \"household.daily_total_view\""
type HouseholdDailyTotalView {
    date: date
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregated selection of \"household.daily_total_view\""
type HouseholdDailyTotalViewAggregate {
    aggregate: HouseholdDailyTotalViewAggregateFields
    nodes: [HouseholdDailyTotalView!]!
}

"aggregate fields of \"household.daily_total_view\""
type HouseholdDailyTotalViewAggregateFields {
    avg: HouseholdDailyTotalViewAvgFields
    count(columns: [HouseholdDailyTotalViewSelectColumn!], distinct: Boolean): Int!
    max: HouseholdDailyTotalViewMaxFields
    min: HouseholdDailyTotalViewMinFields
    stddev: HouseholdDailyTotalViewStddevFields
    stddevPop: HouseholdDailyTotalViewStddevPopFields
    stddevSamp: HouseholdDailyTotalViewStddevSampFields
    sum: HouseholdDailyTotalViewSumFields
    varPop: HouseholdDailyTotalViewVarPopFields
    varSamp: HouseholdDailyTotalViewVarSampFields
    variance: HouseholdDailyTotalViewVarianceFields
}

"aggregate avg on columns"
type HouseholdDailyTotalViewAvgFields {
    total: Float
}

"aggregate max on columns"
type HouseholdDailyTotalViewMaxFields {
    date: date
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregate min on columns"
type HouseholdDailyTotalViewMinFields {
    date: date
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregate stddev on columns"
type HouseholdDailyTotalViewStddevFields {
    total: Float
}

"aggregate stddevPop on columns"
type HouseholdDailyTotalViewStddevPopFields {
    total: Float
}

"aggregate stddevSamp on columns"
type HouseholdDailyTotalViewStddevSampFields {
    total: Float
}

"aggregate sum on columns"
type HouseholdDailyTotalViewSumFields {
    total: numeric
}

"aggregate varPop on columns"
type HouseholdDailyTotalViewVarPopFields {
    total: Float
}

"aggregate varSamp on columns"
type HouseholdDailyTotalViewVarSampFields {
    total: Float
}

"aggregate variance on columns"
type HouseholdDailyTotalViewVarianceFields {
    total: Float
}

"columns and relationships of \"household.deposit_category\""
type HouseholdDepositCategory {
    "An object relationship"
    category: HouseholdCategory!
    categoryId: String!
    "An object relationship"
    group: Group!
    groupId: String!
}

"aggregated selection of \"household.deposit_category\""
type HouseholdDepositCategoryAggregate {
    aggregate: HouseholdDepositCategoryAggregateFields
    nodes: [HouseholdDepositCategory!]!
}

"aggregate fields of \"household.deposit_category\""
type HouseholdDepositCategoryAggregateFields {
    count(columns: [HouseholdDepositCategorySelectColumn!], distinct: Boolean): Int!
    max: HouseholdDepositCategoryMaxFields
    min: HouseholdDepositCategoryMinFields
}

"aggregate max on columns"
type HouseholdDepositCategoryMaxFields {
    categoryId: String
    groupId: String
}

"aggregate min on columns"
type HouseholdDepositCategoryMinFields {
    categoryId: String
    groupId: String
}

"columns and relationships of \"household.genre\""
type HouseholdGenre {
    "An array relationship"
    categories(
        "distinct select on columns"
        distinctOn: [HouseholdCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdCategoryBoolExp
    ): [HouseholdCategory!]!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    displayOrder: Int!
    genreType: String!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    iocomeType: String!
    name: String!
    validFlag: Boolean
}

"aggregated selection of \"household.genre\""
type HouseholdGenreAggregate {
    aggregate: HouseholdGenreAggregateFields
    nodes: [HouseholdGenre!]!
}

"aggregate fields of \"household.genre\""
type HouseholdGenreAggregateFields {
    avg: HouseholdGenreAvgFields
    count(columns: [HouseholdGenreSelectColumn!], distinct: Boolean): Int!
    max: HouseholdGenreMaxFields
    min: HouseholdGenreMinFields
    stddev: HouseholdGenreStddevFields
    stddevPop: HouseholdGenreStddevPopFields
    stddevSamp: HouseholdGenreStddevSampFields
    sum: HouseholdGenreSumFields
    varPop: HouseholdGenreVarPopFields
    varSamp: HouseholdGenreVarSampFields
    variance: HouseholdGenreVarianceFields
}

"aggregate avg on columns"
type HouseholdGenreAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type HouseholdGenreMaxFields {
    displayOrder: Int
    genreType: String
    groupId: String
    id: String
    iocomeType: String
    name: String
}

"aggregate min on columns"
type HouseholdGenreMinFields {
    displayOrder: Int
    genreType: String
    groupId: String
    id: String
    iocomeType: String
    name: String
}

"response of any mutation on the table \"household.genre\""
type HouseholdGenreMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdGenre!]!
}

"aggregate stddev on columns"
type HouseholdGenreStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type HouseholdGenreStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type HouseholdGenreStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type HouseholdGenreSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type HouseholdGenreVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type HouseholdGenreVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type HouseholdGenreVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"household.import_file_history\""
type HouseholdImportFileHistory {
    fileName: String!
    fileType: String!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
    importDatetime: timestamp!
    importUserId: String!
}

"aggregated selection of \"household.import_file_history\""
type HouseholdImportFileHistoryAggregate {
    aggregate: HouseholdImportFileHistoryAggregateFields
    nodes: [HouseholdImportFileHistory!]!
}

"aggregate fields of \"household.import_file_history\""
type HouseholdImportFileHistoryAggregateFields {
    count(columns: [HouseholdImportFileHistorySelectColumn!], distinct: Boolean): Int!
    max: HouseholdImportFileHistoryMaxFields
    min: HouseholdImportFileHistoryMinFields
}

"aggregate max on columns"
type HouseholdImportFileHistoryMaxFields {
    fileName: String
    fileType: String
    groupId: String
    id: String
    importDatetime: timestamp
    importUserId: String
}

"aggregate min on columns"
type HouseholdImportFileHistoryMinFields {
    fileName: String
    fileType: String
    groupId: String
    id: String
    importDatetime: timestamp
    importUserId: String
}

"response of any mutation on the table \"household.import_file_history\""
type HouseholdImportFileHistoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdImportFileHistory!]!
}

"columns and relationships of \"household.summary_category\""
type HouseholdSummaryCategory {
    "An object relationship"
    category: HouseholdCategory!
    categoryId: String!
    displayOrder: Int!
    "An object relationship"
    group: Group!
    groupId: String!
    id: String!
}

"aggregated selection of \"household.summary_category\""
type HouseholdSummaryCategoryAggregate {
    aggregate: HouseholdSummaryCategoryAggregateFields
    nodes: [HouseholdSummaryCategory!]!
}

"aggregate fields of \"household.summary_category\""
type HouseholdSummaryCategoryAggregateFields {
    avg: HouseholdSummaryCategoryAvgFields
    count(columns: [HouseholdSummaryCategorySelectColumn!], distinct: Boolean): Int!
    max: HouseholdSummaryCategoryMaxFields
    min: HouseholdSummaryCategoryMinFields
    stddev: HouseholdSummaryCategoryStddevFields
    stddevPop: HouseholdSummaryCategoryStddevPopFields
    stddevSamp: HouseholdSummaryCategoryStddevSampFields
    sum: HouseholdSummaryCategorySumFields
    varPop: HouseholdSummaryCategoryVarPopFields
    varSamp: HouseholdSummaryCategoryVarSampFields
    variance: HouseholdSummaryCategoryVarianceFields
}

"aggregate avg on columns"
type HouseholdSummaryCategoryAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type HouseholdSummaryCategoryMaxFields {
    categoryId: String
    displayOrder: Int
    groupId: String
    id: String
}

"aggregate min on columns"
type HouseholdSummaryCategoryMinFields {
    categoryId: String
    displayOrder: Int
    groupId: String
    id: String
}

"response of any mutation on the table \"household.summary_category\""
type HouseholdSummaryCategoryMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [HouseholdSummaryCategory!]!
}

"aggregate stddev on columns"
type HouseholdSummaryCategoryStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type HouseholdSummaryCategoryStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type HouseholdSummaryCategoryStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type HouseholdSummaryCategorySumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type HouseholdSummaryCategoryVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type HouseholdSummaryCategoryVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type HouseholdSummaryCategoryVarianceFields {
    displayOrder: Float
}

"columns and relationships of \"household.total_by_category_view\""
type HouseholdTotalByCategoryView {
    categoryId: String
    categoryName: String
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

type HouseholdTotalByCategoryViewAggregate {
    aggregate: HouseholdTotalByCategoryViewAggregateFields
    nodes: [HouseholdTotalByCategoryView!]!
}

"aggregate fields of \"household.total_by_category_view\""
type HouseholdTotalByCategoryViewAggregateFields {
    avg: HouseholdTotalByCategoryViewAvgFields
    count(columns: [HouseholdTotalByCategoryViewSelectColumn!], distinct: Boolean): Int!
    max: HouseholdTotalByCategoryViewMaxFields
    min: HouseholdTotalByCategoryViewMinFields
    stddev: HouseholdTotalByCategoryViewStddevFields
    stddevPop: HouseholdTotalByCategoryViewStddevPopFields
    stddevSamp: HouseholdTotalByCategoryViewStddevSampFields
    sum: HouseholdTotalByCategoryViewSumFields
    varPop: HouseholdTotalByCategoryViewVarPopFields
    varSamp: HouseholdTotalByCategoryViewVarSampFields
    variance: HouseholdTotalByCategoryViewVarianceFields
}

"aggregate avg on columns"
type HouseholdTotalByCategoryViewAvgFields {
    total: Float
}

"aggregate max on columns"
type HouseholdTotalByCategoryViewMaxFields {
    categoryId: String
    categoryName: String
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregate min on columns"
type HouseholdTotalByCategoryViewMinFields {
    categoryId: String
    categoryName: String
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregate stddev on columns"
type HouseholdTotalByCategoryViewStddevFields {
    total: Float
}

"aggregate stddevPop on columns"
type HouseholdTotalByCategoryViewStddevPopFields {
    total: Float
}

"aggregate stddevSamp on columns"
type HouseholdTotalByCategoryViewStddevSampFields {
    total: Float
}

"aggregate sum on columns"
type HouseholdTotalByCategoryViewSumFields {
    total: numeric
}

"aggregate varPop on columns"
type HouseholdTotalByCategoryViewVarPopFields {
    total: Float
}

"aggregate varSamp on columns"
type HouseholdTotalByCategoryViewVarSampFields {
    total: Float
}

"aggregate variance on columns"
type HouseholdTotalByCategoryViewVarianceFields {
    total: Float
}

"columns and relationships of \"household.total_by_genre_view\""
type HouseholdTotalByGenreView {
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

type HouseholdTotalByGenreViewAggregate {
    aggregate: HouseholdTotalByGenreViewAggregateFields
    nodes: [HouseholdTotalByGenreView!]!
}

"aggregate fields of \"household.total_by_genre_view\""
type HouseholdTotalByGenreViewAggregateFields {
    avg: HouseholdTotalByGenreViewAvgFields
    count(columns: [HouseholdTotalByGenreViewSelectColumn!], distinct: Boolean): Int!
    max: HouseholdTotalByGenreViewMaxFields
    min: HouseholdTotalByGenreViewMinFields
    stddev: HouseholdTotalByGenreViewStddevFields
    stddevPop: HouseholdTotalByGenreViewStddevPopFields
    stddevSamp: HouseholdTotalByGenreViewStddevSampFields
    sum: HouseholdTotalByGenreViewSumFields
    varPop: HouseholdTotalByGenreViewVarPopFields
    varSamp: HouseholdTotalByGenreViewVarSampFields
    variance: HouseholdTotalByGenreViewVarianceFields
}

"aggregate avg on columns"
type HouseholdTotalByGenreViewAvgFields {
    total: Float
}

"aggregate max on columns"
type HouseholdTotalByGenreViewMaxFields {
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregate min on columns"
type HouseholdTotalByGenreViewMinFields {
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

"aggregate stddev on columns"
type HouseholdTotalByGenreViewStddevFields {
    total: Float
}

"aggregate stddevPop on columns"
type HouseholdTotalByGenreViewStddevPopFields {
    total: Float
}

"aggregate stddevSamp on columns"
type HouseholdTotalByGenreViewStddevSampFields {
    total: Float
}

"aggregate sum on columns"
type HouseholdTotalByGenreViewSumFields {
    total: numeric
}

"aggregate varPop on columns"
type HouseholdTotalByGenreViewVarPopFields {
    total: Float
}

"aggregate varSamp on columns"
type HouseholdTotalByGenreViewVarSampFields {
    total: Float
}

"aggregate variance on columns"
type HouseholdTotalByGenreViewVarianceFields {
    total: Float
}

"columns and relationships of \"household.transfer_category\""
type HouseholdTransferCategory {
    "An object relationship"
    categoryByIncomeCategoryId: HouseholdCategory!
    "An object relationship"
    categoryByOutcomeCategoryId: HouseholdCategory!
    "An object relationship"
    group: Group!
    groupId: String!
    incomeCategoryId: String!
    outcomeCategoryId: String!
}

"aggregated selection of \"household.transfer_category\""
type HouseholdTransferCategoryAggregate {
    aggregate: HouseholdTransferCategoryAggregateFields
    nodes: [HouseholdTransferCategory!]!
}

"aggregate fields of \"household.transfer_category\""
type HouseholdTransferCategoryAggregateFields {
    count(columns: [HouseholdTransferCategorySelectColumn!], distinct: Boolean): Int!
    max: HouseholdTransferCategoryMaxFields
    min: HouseholdTransferCategoryMinFields
}

"aggregate max on columns"
type HouseholdTransferCategoryMaxFields {
    groupId: String
    incomeCategoryId: String
    outcomeCategoryId: String
}

"aggregate min on columns"
type HouseholdTransferCategoryMinFields {
    groupId: String
    incomeCategoryId: String
    outcomeCategoryId: String
}

"columns and relationships of \"user\""
type User {
    "An array relationship"
    affiliations(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "An aggregate relationship"
    affiliationsAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "An array relationship"
    creditCardDetails(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "An aggregate relationship"
    creditCardDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "An array relationship"
    dailyDetails(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "An aggregate relationship"
    dailyDetailsAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    displayOrder: Int
    email: String!
    id: String!
    name: String
}

"aggregated selection of \"user\""
type UserAggregate {
    aggregate: UserAggregateFields
    nodes: [User!]!
}

"aggregate fields of \"user\""
type UserAggregateFields {
    avg: UserAvgFields
    count(columns: [UserSelectColumn!], distinct: Boolean): Int!
    max: UserMaxFields
    min: UserMinFields
    stddev: UserStddevFields
    stddevPop: UserStddevPopFields
    stddevSamp: UserStddevSampFields
    sum: UserSumFields
    varPop: UserVarPopFields
    varSamp: UserVarSampFields
    variance: UserVarianceFields
}

"aggregate avg on columns"
type UserAvgFields {
    displayOrder: Float
}

"aggregate max on columns"
type UserMaxFields {
    displayOrder: Int
    email: String
    id: String
    name: String
}

"aggregate min on columns"
type UserMinFields {
    displayOrder: Int
    email: String
    id: String
    name: String
}

"response of any mutation on the table \"user\""
type UserMutationResponse {
    "number of rows affected by the mutation"
    affectedRows: Int!
    "data from the rows affected by the mutation"
    returning: [User!]!
}

"aggregate stddev on columns"
type UserStddevFields {
    displayOrder: Float
}

"aggregate stddevPop on columns"
type UserStddevPopFields {
    displayOrder: Float
}

"aggregate stddevSamp on columns"
type UserStddevSampFields {
    displayOrder: Float
}

"aggregate sum on columns"
type UserSumFields {
    displayOrder: Int
}

"aggregate varPop on columns"
type UserVarPopFields {
    displayOrder: Float
}

"aggregate varSamp on columns"
type UserVarSampFields {
    displayOrder: Float
}

"aggregate variance on columns"
type UserVarianceFields {
    displayOrder: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"household.daily_detail\""
    deleteHouseholdDailyDetail(
        "filter the rows which have to be deleted"
        where: HouseholdDailyDetailBoolExp!
    ): HouseholdDailyDetailMutationResponse
    "delete single row from the table: \"household.daily_detail\""
    deleteHouseholdDailyDetailByPk(id: String!): HouseholdDailyDetail
    "delete data from the table: \"household.summary_category\""
    deleteHouseholdSummaryCategory(
        "filter the rows which have to be deleted"
        where: HouseholdSummaryCategoryBoolExp!
    ): HouseholdSummaryCategoryMutationResponse
    "delete single row from the table: \"household.summary_category\""
    deleteHouseholdSummaryCategoryByPk(id: String!): HouseholdSummaryCategory
    "insert data into the table: \"affiliation\""
    insertAffiliation(
        "the rows to be inserted"
        objects: [AffiliationInsertInput!]!,
        "upsert condition"
        onConflict: AffiliationOnConflict
    ): AffiliationMutationResponse
    "insert a single row into the table: \"affiliation\""
    insertAffiliationOne(
        "the row to be inserted"
        object: AffiliationInsertInput!,
        "upsert condition"
        onConflict: AffiliationOnConflict
    ): Affiliation
    "insert data into the table: \"household.account\""
    insertHouseholdAccount(
        "the rows to be inserted"
        objects: [HouseholdAccountInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdAccountOnConflict
    ): HouseholdAccountMutationResponse
    "insert a single row into the table: \"household.account\""
    insertHouseholdAccountOne(
        "the row to be inserted"
        object: HouseholdAccountInsertInput!,
        "upsert condition"
        onConflict: HouseholdAccountOnConflict
    ): HouseholdAccount
    "insert data into the table: \"household.category\""
    insertHouseholdCategory(
        "the rows to be inserted"
        objects: [HouseholdCategoryInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdCategoryOnConflict
    ): HouseholdCategoryMutationResponse
    "insert a single row into the table: \"household.category\""
    insertHouseholdCategoryOne(
        "the row to be inserted"
        object: HouseholdCategoryInsertInput!,
        "upsert condition"
        onConflict: HouseholdCategoryOnConflict
    ): HouseholdCategory
    "insert data into the table: \"household.credit_card_detail\""
    insertHouseholdCreditCardDetail(
        "the rows to be inserted"
        objects: [HouseholdCreditCardDetailInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdCreditCardDetailOnConflict
    ): HouseholdCreditCardDetailMutationResponse
    "insert a single row into the table: \"household.credit_card_detail\""
    insertHouseholdCreditCardDetailOne(
        "the row to be inserted"
        object: HouseholdCreditCardDetailInsertInput!,
        "upsert condition"
        onConflict: HouseholdCreditCardDetailOnConflict
    ): HouseholdCreditCardDetail
    "insert data into the table: \"household.credit_card_summary\""
    insertHouseholdCreditCardSummary(
        "the rows to be inserted"
        objects: [HouseholdCreditCardSummaryInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdCreditCardSummaryOnConflict
    ): HouseholdCreditCardSummaryMutationResponse
    "insert a single row into the table: \"household.credit_card_summary\""
    insertHouseholdCreditCardSummaryOne(
        "the row to be inserted"
        object: HouseholdCreditCardSummaryInsertInput!,
        "upsert condition"
        onConflict: HouseholdCreditCardSummaryOnConflict
    ): HouseholdCreditCardSummary
    "insert data into the table: \"household.daily_detail\""
    insertHouseholdDailyDetail(
        "the rows to be inserted"
        objects: [HouseholdDailyDetailInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdDailyDetailOnConflict
    ): HouseholdDailyDetailMutationResponse
    "insert a single row into the table: \"household.daily_detail\""
    insertHouseholdDailyDetailOne(
        "the row to be inserted"
        object: HouseholdDailyDetailInsertInput!,
        "upsert condition"
        onConflict: HouseholdDailyDetailOnConflict
    ): HouseholdDailyDetail
    "insert data into the table: \"household.genre\""
    insertHouseholdGenre(
        "the rows to be inserted"
        objects: [HouseholdGenreInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdGenreOnConflict
    ): HouseholdGenreMutationResponse
    "insert a single row into the table: \"household.genre\""
    insertHouseholdGenreOne(
        "the row to be inserted"
        object: HouseholdGenreInsertInput!,
        "upsert condition"
        onConflict: HouseholdGenreOnConflict
    ): HouseholdGenre
    "insert data into the table: \"household.import_file_history\""
    insertHouseholdImportFileHistory(
        "the rows to be inserted"
        objects: [HouseholdImportFileHistoryInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdImportFileHistoryOnConflict
    ): HouseholdImportFileHistoryMutationResponse
    "insert a single row into the table: \"household.import_file_history\""
    insertHouseholdImportFileHistoryOne(
        "the row to be inserted"
        object: HouseholdImportFileHistoryInsertInput!,
        "upsert condition"
        onConflict: HouseholdImportFileHistoryOnConflict
    ): HouseholdImportFileHistory
    "insert data into the table: \"household.summary_category\""
    insertHouseholdSummaryCategory(
        "the rows to be inserted"
        objects: [HouseholdSummaryCategoryInsertInput!]!,
        "upsert condition"
        onConflict: HouseholdSummaryCategoryOnConflict
    ): HouseholdSummaryCategoryMutationResponse
    "insert a single row into the table: \"household.summary_category\""
    insertHouseholdSummaryCategoryOne(
        "the row to be inserted"
        object: HouseholdSummaryCategoryInsertInput!,
        "upsert condition"
        onConflict: HouseholdSummaryCategoryOnConflict
    ): HouseholdSummaryCategory
    "insert data into the table: \"user\""
    insertUser(
        "the rows to be inserted"
        objects: [UserInsertInput!]!,
        "upsert condition"
        onConflict: UserOnConflict
    ): UserMutationResponse
    "insert a single row into the table: \"user\""
    insertUserOne(
        "the row to be inserted"
        object: UserInsertInput!,
        "upsert condition"
        onConflict: UserOnConflict
    ): User
    "update data of the table: \"household.category\""
    updateHouseholdCategory(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdCategoryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdCategorySetInput,
        "filter the rows which have to be updated"
        where: HouseholdCategoryBoolExp!
    ): HouseholdCategoryMutationResponse
    "update single row of the table: \"household.category\""
    updateHouseholdCategoryByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdCategoryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdCategorySetInput,
        pkColumns: HouseholdCategoryPkColumnsInput!
    ): HouseholdCategory
    "update multiples rows of table: \"household.category\""
    updateHouseholdCategoryMany(
        "updates to execute, in order"
        updates: [HouseholdCategoryUpdates!]!
    ): [HouseholdCategoryMutationResponse]
    "update data of the table: \"household.credit_card_detail\""
    updateHouseholdCreditCardDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdCreditCardDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdCreditCardDetailSetInput,
        "filter the rows which have to be updated"
        where: HouseholdCreditCardDetailBoolExp!
    ): HouseholdCreditCardDetailMutationResponse
    "update single row of the table: \"household.credit_card_detail\""
    updateHouseholdCreditCardDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdCreditCardDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdCreditCardDetailSetInput,
        pkColumns: HouseholdCreditCardDetailPkColumnsInput!
    ): HouseholdCreditCardDetail
    "update multiples rows of table: \"household.credit_card_detail\""
    updateHouseholdCreditCardDetailMany(
        "updates to execute, in order"
        updates: [HouseholdCreditCardDetailUpdates!]!
    ): [HouseholdCreditCardDetailMutationResponse]
    "update data of the table: \"household.credit_card_summary\""
    updateHouseholdCreditCardSummary(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdCreditCardSummaryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdCreditCardSummarySetInput,
        "filter the rows which have to be updated"
        where: HouseholdCreditCardSummaryBoolExp!
    ): HouseholdCreditCardSummaryMutationResponse
    "update single row of the table: \"household.credit_card_summary\""
    updateHouseholdCreditCardSummaryByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdCreditCardSummaryIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdCreditCardSummarySetInput,
        pkColumns: HouseholdCreditCardSummaryPkColumnsInput!
    ): HouseholdCreditCardSummary
    "update multiples rows of table: \"household.credit_card_summary\""
    updateHouseholdCreditCardSummaryMany(
        "updates to execute, in order"
        updates: [HouseholdCreditCardSummaryUpdates!]!
    ): [HouseholdCreditCardSummaryMutationResponse]
    "update data of the table: \"household.daily_detail\""
    updateHouseholdDailyDetail(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdDailyDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdDailyDetailSetInput,
        "filter the rows which have to be updated"
        where: HouseholdDailyDetailBoolExp!
    ): HouseholdDailyDetailMutationResponse
    "update single row of the table: \"household.daily_detail\""
    updateHouseholdDailyDetailByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdDailyDetailIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdDailyDetailSetInput,
        pkColumns: HouseholdDailyDetailPkColumnsInput!
    ): HouseholdDailyDetail
    "update multiples rows of table: \"household.daily_detail\""
    updateHouseholdDailyDetailMany(
        "updates to execute, in order"
        updates: [HouseholdDailyDetailUpdates!]!
    ): [HouseholdDailyDetailMutationResponse]
    "update data of the table: \"household.genre\""
    updateHouseholdGenre(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdGenreIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdGenreSetInput,
        "filter the rows which have to be updated"
        where: HouseholdGenreBoolExp!
    ): HouseholdGenreMutationResponse
    "update single row of the table: \"household.genre\""
    updateHouseholdGenreByPk(
        "increments the numeric columns with given value of the filtered values"
        _inc: HouseholdGenreIncInput,
        "sets the columns of the filtered rows to the given values"
        _set: HouseholdGenreSetInput,
        pkColumns: HouseholdGenrePkColumnsInput!
    ): HouseholdGenre
    "update multiples rows of table: \"household.genre\""
    updateHouseholdGenreMany(
        "updates to execute, in order"
        updates: [HouseholdGenreUpdates!]!
    ): [HouseholdGenreMutationResponse]
}

type query_root {
    "fetch data from the table: \"affiliation\""
    affiliation(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch aggregated fields from the table: \"affiliation\""
    affiliationAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "fetch data from the table: \"affiliation\" using primary key columns"
    affiliationByPk(id: String!): Affiliation
    "fetch data from the table: \"application\""
    application(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch aggregated fields from the table: \"application\""
    applicationAggregate(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): ApplicationAggregate!
    "fetch data from the table: \"application\" using primary key columns"
    applicationByPk(id: String!): Application
    "execute function \"category_total_by_month\" which returns \"household.total_by_category_view\""
    categoryTotalByMonth(
        "input parameters for function \"categoryTotalByMonth\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): [HouseholdTotalByCategoryView!]!
    "execute function \"category_total_by_month\" and query aggregates on result of table type \"household.total_by_category_view\""
    categoryTotalByMonthAggregate(
        "input parameters for function \"categoryTotalByMonthAggregate\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): HouseholdTotalByCategoryViewAggregate!
    "execute function \"daily_detail_by_date\" which returns \"household.daily_detail\""
    dailyDetailByDate(
        "input parameters for function \"dailyDetailByDate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "execute function \"daily_detail_by_date\" and query aggregates on result of table type \"household.daily_detail\""
    dailyDetailByDateAggregate(
        "input parameters for function \"dailyDetailByDateAggregate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    "execute function \"genre_total_by_month\" which returns \"household.total_by_genre_view\""
    genreTotalByMonth(
        "input parameters for function \"genreTotalByMonth\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): [HouseholdTotalByGenreView!]!
    "execute function \"genre_total_by_month\" and query aggregates on result of table type \"household.total_by_genre_view\""
    genreTotalByMonthAggregate(
        "input parameters for function \"genreTotalByMonthAggregate\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): HouseholdTotalByGenreViewAggregate!
    "fetch data from the table: \"group\""
    group(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch aggregated fields from the table: \"group\""
    groupAggregate(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): GroupAggregate!
    "fetch data from the table: \"group_application\""
    groupApplication(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch aggregated fields from the table: \"group_application\""
    groupApplicationAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    "fetch data from the table: \"group_application\" using primary key columns"
    groupApplicationByPk(id: String!): GroupApplication
    "fetch data from the table: \"group\" using primary key columns"
    groupByPk(id: String!): Group
    "fetch data from the table: \"household.account\""
    householdAccount(
        "distinct select on columns"
        distinctOn: [HouseholdAccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAccountOrderBy!],
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): [HouseholdAccount!]!
    "fetch aggregated fields from the table: \"household.account\""
    householdAccountAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdAccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAccountOrderBy!],
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): HouseholdAccountAggregate!
    "fetch data from the table: \"household.account\" using primary key columns"
    householdAccountByPk(id: String!): HouseholdAccount
    "fetch data from the table: \"household.all_detail_view\""
    householdAllDetailView(
        "distinct select on columns"
        distinctOn: [HouseholdAllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAllDetailViewOrderBy!],
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): [HouseholdAllDetailView!]!
    "fetch aggregated fields from the table: \"household.all_detail_view\""
    householdAllDetailViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdAllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAllDetailViewOrderBy!],
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): HouseholdAllDetailViewAggregate!
    "fetch data from the table: \"household.category\""
    householdCategory(
        "distinct select on columns"
        distinctOn: [HouseholdCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdCategoryBoolExp
    ): [HouseholdCategory!]!
    "fetch data from the table: \"household.category\" using primary key columns"
    householdCategoryByPk(id: String!): HouseholdCategory
    "fetch data from the table: \"household.credit_card_detail\""
    householdCreditCardDetail(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "fetch aggregated fields from the table: \"household.credit_card_detail\""
    householdCreditCardDetailAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "fetch data from the table: \"household.credit_card_detail\" using primary key columns"
    householdCreditCardDetailByPk(id: String!): HouseholdCreditCardDetail
    "fetch data from the table: \"household.credit_card_summary\""
    householdCreditCardSummary(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): [HouseholdCreditCardSummary!]!
    "fetch aggregated fields from the table: \"household.credit_card_summary\""
    householdCreditCardSummaryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): HouseholdCreditCardSummaryAggregate!
    "fetch data from the table: \"household.credit_card_summary\" using primary key columns"
    householdCreditCardSummaryByPk(id: String!): HouseholdCreditCardSummary
    "fetch data from the table: \"household.credit_card_summary_total_by_account_view\""
    householdCreditCardSummaryTotalByAccountView(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryTotalByAccountViewBoolExp
    ): [HouseholdCreditCardSummaryTotalByAccountView!]!
    "fetch aggregated fields from the table: \"household.credit_card_summary_total_by_account_view\""
    householdCreditCardSummaryTotalByAccountViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryTotalByAccountViewBoolExp
    ): HouseholdCreditCardSummaryTotalByAccountViewAggregate!
    "fetch data from the table: \"household.daily_detail\""
    householdDailyDetail(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "fetch aggregated fields from the table: \"household.daily_detail\""
    householdDailyDetailAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    "fetch data from the table: \"household.daily_detail\" using primary key columns"
    householdDailyDetailByPk(id: String!): HouseholdDailyDetail
    "fetch data from the table: \"household.daily_total_view\""
    householdDailyTotalView(
        "distinct select on columns"
        distinctOn: [HouseholdDailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyTotalViewOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyTotalViewBoolExp
    ): [HouseholdDailyTotalView!]!
    "fetch aggregated fields from the table: \"household.daily_total_view\""
    householdDailyTotalViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyTotalViewOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyTotalViewBoolExp
    ): HouseholdDailyTotalViewAggregate!
    "fetch data from the table: \"household.deposit_category\""
    householdDepositCategory(
        "distinct select on columns"
        distinctOn: [HouseholdDepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDepositCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): [HouseholdDepositCategory!]!
    "fetch aggregated fields from the table: \"household.deposit_category\""
    householdDepositCategoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDepositCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): HouseholdDepositCategoryAggregate!
    "fetch data from the table: \"household.deposit_category\" using primary key columns"
    householdDepositCategoryByPk(categoryId: String!): HouseholdDepositCategory
    "fetch data from the table: \"household.genre\""
    householdGenre(
        "distinct select on columns"
        distinctOn: [HouseholdGenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdGenreOrderBy!],
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): [HouseholdGenre!]!
    "fetch aggregated fields from the table: \"household.genre\""
    householdGenreAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdGenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdGenreOrderBy!],
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): HouseholdGenreAggregate!
    "fetch data from the table: \"household.genre\" using primary key columns"
    householdGenreByPk(id: String!): HouseholdGenre
    "fetch data from the table: \"household.import_file_history\""
    householdImportFileHistory(
        "distinct select on columns"
        distinctOn: [HouseholdImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): [HouseholdImportFileHistory!]!
    "fetch aggregated fields from the table: \"household.import_file_history\""
    householdImportFileHistoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): HouseholdImportFileHistoryAggregate!
    "fetch data from the table: \"household.import_file_history\" using primary key columns"
    householdImportFileHistoryByPk(id: String!): HouseholdImportFileHistory
    "fetch data from the table: \"household.summary_category\""
    householdSummaryCategory(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): [HouseholdSummaryCategory!]!
    "fetch aggregated fields from the table: \"household.summary_category\""
    householdSummaryCategoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): HouseholdSummaryCategoryAggregate!
    "fetch data from the table: \"household.summary_category\" using primary key columns"
    householdSummaryCategoryByPk(id: String!): HouseholdSummaryCategory
    "fetch data from the table: \"household.total_by_category_view\""
    householdTotalByCategoryView(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): [HouseholdTotalByCategoryView!]!
    "fetch aggregated fields from the table: \"household.total_by_category_view\""
    householdTotalByCategoryViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): HouseholdTotalByCategoryViewAggregate!
    "fetch data from the table: \"household.total_by_genre_view\""
    householdTotalByGenreView(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): [HouseholdTotalByGenreView!]!
    "fetch aggregated fields from the table: \"household.total_by_genre_view\""
    householdTotalByGenreViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): HouseholdTotalByGenreViewAggregate!
    "fetch data from the table: \"household.transfer_category\""
    householdTransferCategory(
        "distinct select on columns"
        distinctOn: [HouseholdTransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTransferCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): [HouseholdTransferCategory!]!
    "fetch aggregated fields from the table: \"household.transfer_category\""
    householdTransferCategoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTransferCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): HouseholdTransferCategoryAggregate!
    "fetch data from the table: \"household.transfer_category\" using primary key columns"
    householdTransferCategoryByPk(groupId: String!): HouseholdTransferCategory
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
    "fetch aggregated fields from the table: \"user\""
    userAggregate(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): UserAggregate!
    "fetch data from the table: \"user\" using primary key columns"
    userByPk(id: String!): User
}

type subscription_root {
    "fetch data from the table: \"affiliation\""
    affiliation(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch aggregated fields from the table: \"affiliation\""
    affiliationAggregate(
        "distinct select on columns"
        distinctOn: [AffiliationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [AffiliationOrderBy!],
        "filter the rows returned"
        where: AffiliationBoolExp
    ): AffiliationAggregate!
    "fetch data from the table: \"affiliation\" using primary key columns"
    affiliationByPk(id: String!): Affiliation
    "fetch data from the table in a streaming manner: \"affiliation\""
    affiliationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [AffiliationStreamCursorInput]!,
        "filter the rows returned"
        where: AffiliationBoolExp
    ): [Affiliation!]!
    "fetch data from the table: \"application\""
    application(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "fetch aggregated fields from the table: \"application\""
    applicationAggregate(
        "distinct select on columns"
        distinctOn: [ApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [ApplicationOrderBy!],
        "filter the rows returned"
        where: ApplicationBoolExp
    ): ApplicationAggregate!
    "fetch data from the table: \"application\" using primary key columns"
    applicationByPk(id: String!): Application
    "fetch data from the table in a streaming manner: \"application\""
    applicationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [ApplicationStreamCursorInput]!,
        "filter the rows returned"
        where: ApplicationBoolExp
    ): [Application!]!
    "execute function \"category_total_by_month\" which returns \"household.total_by_category_view\""
    categoryTotalByMonth(
        "input parameters for function \"categoryTotalByMonth\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): [HouseholdTotalByCategoryView!]!
    "execute function \"category_total_by_month\" and query aggregates on result of table type \"household.total_by_category_view\""
    categoryTotalByMonthAggregate(
        "input parameters for function \"categoryTotalByMonthAggregate\""
        args: categoryTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): HouseholdTotalByCategoryViewAggregate!
    "execute function \"daily_detail_by_date\" which returns \"household.daily_detail\""
    dailyDetailByDate(
        "input parameters for function \"dailyDetailByDate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "execute function \"daily_detail_by_date\" and query aggregates on result of table type \"household.daily_detail\""
    dailyDetailByDateAggregate(
        "input parameters for function \"dailyDetailByDateAggregate\""
        args: dailyDetailByDateArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    "execute function \"genre_total_by_month\" which returns \"household.total_by_genre_view\""
    genreTotalByMonth(
        "input parameters for function \"genreTotalByMonth\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): [HouseholdTotalByGenreView!]!
    "execute function \"genre_total_by_month\" and query aggregates on result of table type \"household.total_by_genre_view\""
    genreTotalByMonthAggregate(
        "input parameters for function \"genreTotalByMonthAggregate\""
        args: genreTotalByMonthArgs!,
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): HouseholdTotalByGenreViewAggregate!
    "fetch data from the table: \"group\""
    group(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch aggregated fields from the table: \"group\""
    groupAggregate(
        "distinct select on columns"
        distinctOn: [GroupSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupOrderBy!],
        "filter the rows returned"
        where: GroupBoolExp
    ): GroupAggregate!
    "fetch data from the table: \"group_application\""
    groupApplication(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch aggregated fields from the table: \"group_application\""
    groupApplicationAggregate(
        "distinct select on columns"
        distinctOn: [GroupApplicationSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [GroupApplicationOrderBy!],
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): GroupApplicationAggregate!
    "fetch data from the table: \"group_application\" using primary key columns"
    groupApplicationByPk(id: String!): GroupApplication
    "fetch data from the table in a streaming manner: \"group_application\""
    groupApplicationStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupApplicationStreamCursorInput]!,
        "filter the rows returned"
        where: GroupApplicationBoolExp
    ): [GroupApplication!]!
    "fetch data from the table: \"group\" using primary key columns"
    groupByPk(id: String!): Group
    "fetch data from the table in a streaming manner: \"group\""
    groupStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [GroupStreamCursorInput]!,
        "filter the rows returned"
        where: GroupBoolExp
    ): [Group!]!
    "fetch data from the table: \"household.account\""
    householdAccount(
        "distinct select on columns"
        distinctOn: [HouseholdAccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAccountOrderBy!],
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): [HouseholdAccount!]!
    "fetch aggregated fields from the table: \"household.account\""
    householdAccountAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdAccountSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAccountOrderBy!],
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): HouseholdAccountAggregate!
    "fetch data from the table: \"household.account\" using primary key columns"
    householdAccountByPk(id: String!): HouseholdAccount
    "fetch data from the table in a streaming manner: \"household.account\""
    householdAccountStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdAccountStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdAccountBoolExp
    ): [HouseholdAccount!]!
    "fetch data from the table: \"household.all_detail_view\""
    householdAllDetailView(
        "distinct select on columns"
        distinctOn: [HouseholdAllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAllDetailViewOrderBy!],
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): [HouseholdAllDetailView!]!
    "fetch aggregated fields from the table: \"household.all_detail_view\""
    householdAllDetailViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdAllDetailViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdAllDetailViewOrderBy!],
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): HouseholdAllDetailViewAggregate!
    "fetch data from the table in a streaming manner: \"household.all_detail_view\""
    householdAllDetailViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdAllDetailViewStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdAllDetailViewBoolExp
    ): [HouseholdAllDetailView!]!
    "fetch data from the table: \"household.category\""
    householdCategory(
        "distinct select on columns"
        distinctOn: [HouseholdCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdCategoryBoolExp
    ): [HouseholdCategory!]!
    "fetch data from the table: \"household.category\" using primary key columns"
    householdCategoryByPk(id: String!): HouseholdCategory
    "fetch data from the table in a streaming manner: \"household.category\""
    householdCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdCategoryBoolExp
    ): [HouseholdCategory!]!
    "fetch data from the table: \"household.credit_card_detail\""
    householdCreditCardDetail(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "fetch aggregated fields from the table: \"household.credit_card_detail\""
    householdCreditCardDetailAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): HouseholdCreditCardDetailAggregate!
    "fetch data from the table: \"household.credit_card_detail\" using primary key columns"
    householdCreditCardDetailByPk(id: String!): HouseholdCreditCardDetail
    "fetch data from the table in a streaming manner: \"household.credit_card_detail\""
    householdCreditCardDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdCreditCardDetailStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdCreditCardDetailBoolExp
    ): [HouseholdCreditCardDetail!]!
    "fetch data from the table: \"household.credit_card_summary\""
    householdCreditCardSummary(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): [HouseholdCreditCardSummary!]!
    "fetch aggregated fields from the table: \"household.credit_card_summary\""
    householdCreditCardSummaryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummarySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): HouseholdCreditCardSummaryAggregate!
    "fetch data from the table: \"household.credit_card_summary\" using primary key columns"
    householdCreditCardSummaryByPk(id: String!): HouseholdCreditCardSummary
    "fetch data from the table in a streaming manner: \"household.credit_card_summary\""
    householdCreditCardSummaryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdCreditCardSummaryStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdCreditCardSummaryBoolExp
    ): [HouseholdCreditCardSummary!]!
    "fetch data from the table: \"household.credit_card_summary_total_by_account_view\""
    householdCreditCardSummaryTotalByAccountView(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryTotalByAccountViewBoolExp
    ): [HouseholdCreditCardSummaryTotalByAccountView!]!
    "fetch aggregated fields from the table: \"household.credit_card_summary_total_by_account_view\""
    householdCreditCardSummaryTotalByAccountViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdCreditCardSummaryTotalByAccountViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdCreditCardSummaryTotalByAccountViewOrderBy!],
        "filter the rows returned"
        where: HouseholdCreditCardSummaryTotalByAccountViewBoolExp
    ): HouseholdCreditCardSummaryTotalByAccountViewAggregate!
    "fetch data from the table in a streaming manner: \"household.credit_card_summary_total_by_account_view\""
    householdCreditCardSummaryTotalByAccountViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdCreditCardSummaryTotalByAccountViewStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdCreditCardSummaryTotalByAccountViewBoolExp
    ): [HouseholdCreditCardSummaryTotalByAccountView!]!
    "fetch data from the table: \"household.daily_detail\""
    householdDailyDetail(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "fetch aggregated fields from the table: \"household.daily_detail\""
    householdDailyDetailAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyDetailSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyDetailOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): HouseholdDailyDetailAggregate!
    "fetch data from the table: \"household.daily_detail\" using primary key columns"
    householdDailyDetailByPk(id: String!): HouseholdDailyDetail
    "fetch data from the table in a streaming manner: \"household.daily_detail\""
    householdDailyDetailStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdDailyDetailStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdDailyDetailBoolExp
    ): [HouseholdDailyDetail!]!
    "fetch data from the table: \"household.daily_total_view\""
    householdDailyTotalView(
        "distinct select on columns"
        distinctOn: [HouseholdDailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyTotalViewOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyTotalViewBoolExp
    ): [HouseholdDailyTotalView!]!
    "fetch aggregated fields from the table: \"household.daily_total_view\""
    householdDailyTotalViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDailyTotalViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDailyTotalViewOrderBy!],
        "filter the rows returned"
        where: HouseholdDailyTotalViewBoolExp
    ): HouseholdDailyTotalViewAggregate!
    "fetch data from the table in a streaming manner: \"household.daily_total_view\""
    householdDailyTotalViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdDailyTotalViewStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdDailyTotalViewBoolExp
    ): [HouseholdDailyTotalView!]!
    "fetch data from the table: \"household.deposit_category\""
    householdDepositCategory(
        "distinct select on columns"
        distinctOn: [HouseholdDepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDepositCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): [HouseholdDepositCategory!]!
    "fetch aggregated fields from the table: \"household.deposit_category\""
    householdDepositCategoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdDepositCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdDepositCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): HouseholdDepositCategoryAggregate!
    "fetch data from the table: \"household.deposit_category\" using primary key columns"
    householdDepositCategoryByPk(categoryId: String!): HouseholdDepositCategory
    "fetch data from the table in a streaming manner: \"household.deposit_category\""
    householdDepositCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdDepositCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdDepositCategoryBoolExp
    ): [HouseholdDepositCategory!]!
    "fetch data from the table: \"household.genre\""
    householdGenre(
        "distinct select on columns"
        distinctOn: [HouseholdGenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdGenreOrderBy!],
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): [HouseholdGenre!]!
    "fetch aggregated fields from the table: \"household.genre\""
    householdGenreAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdGenreSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdGenreOrderBy!],
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): HouseholdGenreAggregate!
    "fetch data from the table: \"household.genre\" using primary key columns"
    householdGenreByPk(id: String!): HouseholdGenre
    "fetch data from the table in a streaming manner: \"household.genre\""
    householdGenreStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdGenreStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdGenreBoolExp
    ): [HouseholdGenre!]!
    "fetch data from the table: \"household.import_file_history\""
    householdImportFileHistory(
        "distinct select on columns"
        distinctOn: [HouseholdImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): [HouseholdImportFileHistory!]!
    "fetch aggregated fields from the table: \"household.import_file_history\""
    householdImportFileHistoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdImportFileHistorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdImportFileHistoryOrderBy!],
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): HouseholdImportFileHistoryAggregate!
    "fetch data from the table: \"household.import_file_history\" using primary key columns"
    householdImportFileHistoryByPk(id: String!): HouseholdImportFileHistory
    "fetch data from the table in a streaming manner: \"household.import_file_history\""
    householdImportFileHistoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdImportFileHistoryStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdImportFileHistoryBoolExp
    ): [HouseholdImportFileHistory!]!
    "fetch data from the table: \"household.summary_category\""
    householdSummaryCategory(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): [HouseholdSummaryCategory!]!
    "fetch aggregated fields from the table: \"household.summary_category\""
    householdSummaryCategoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdSummaryCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdSummaryCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): HouseholdSummaryCategoryAggregate!
    "fetch data from the table: \"household.summary_category\" using primary key columns"
    householdSummaryCategoryByPk(id: String!): HouseholdSummaryCategory
    "fetch data from the table in a streaming manner: \"household.summary_category\""
    householdSummaryCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdSummaryCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdSummaryCategoryBoolExp
    ): [HouseholdSummaryCategory!]!
    "fetch data from the table: \"household.total_by_category_view\""
    householdTotalByCategoryView(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): [HouseholdTotalByCategoryView!]!
    "fetch aggregated fields from the table: \"household.total_by_category_view\""
    householdTotalByCategoryViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByCategoryViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByCategoryViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): HouseholdTotalByCategoryViewAggregate!
    "fetch data from the table in a streaming manner: \"household.total_by_category_view\""
    householdTotalByCategoryViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdTotalByCategoryViewStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdTotalByCategoryViewBoolExp
    ): [HouseholdTotalByCategoryView!]!
    "fetch data from the table: \"household.total_by_genre_view\""
    householdTotalByGenreView(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): [HouseholdTotalByGenreView!]!
    "fetch aggregated fields from the table: \"household.total_by_genre_view\""
    householdTotalByGenreViewAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTotalByGenreViewSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTotalByGenreViewOrderBy!],
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): HouseholdTotalByGenreViewAggregate!
    "fetch data from the table in a streaming manner: \"household.total_by_genre_view\""
    householdTotalByGenreViewStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdTotalByGenreViewStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdTotalByGenreViewBoolExp
    ): [HouseholdTotalByGenreView!]!
    "fetch data from the table: \"household.transfer_category\""
    householdTransferCategory(
        "distinct select on columns"
        distinctOn: [HouseholdTransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTransferCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): [HouseholdTransferCategory!]!
    "fetch aggregated fields from the table: \"household.transfer_category\""
    householdTransferCategoryAggregate(
        "distinct select on columns"
        distinctOn: [HouseholdTransferCategorySelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [HouseholdTransferCategoryOrderBy!],
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): HouseholdTransferCategoryAggregate!
    "fetch data from the table: \"household.transfer_category\" using primary key columns"
    householdTransferCategoryByPk(groupId: String!): HouseholdTransferCategory
    "fetch data from the table in a streaming manner: \"household.transfer_category\""
    householdTransferCategoryStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [HouseholdTransferCategoryStreamCursorInput]!,
        "filter the rows returned"
        where: HouseholdTransferCategoryBoolExp
    ): [HouseholdTransferCategory!]!
    "fetch data from the table: \"user\""
    user(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
    "fetch aggregated fields from the table: \"user\""
    userAggregate(
        "distinct select on columns"
        distinctOn: [UserSelectColumn!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        orderBy: [UserOrderBy!],
        "filter the rows returned"
        where: UserBoolExp
    ): UserAggregate!
    "fetch data from the table: \"user\" using primary key columns"
    userByPk(id: String!): User
    "fetch data from the table in a streaming manner: \"user\""
    userStream(
        "maximum number of rows returned in a single batch"
        batchSize: Int!,
        "cursor to stream the results returned by the query"
        cursor: [UserStreamCursorInput]!,
        "filter the rows returned"
        where: UserBoolExp
    ): [User!]!
}

"unique or primary key constraints on table \"affiliation\""
enum AffiliationConstraint {
    "unique or primary key constraint on columns \"id\""
    affiliation_pkey
}

"select columns of table \"affiliation\""
enum AffiliationSelectColumn {
    "column name"
    groupId
    "column name"
    groupRole
    "column name"
    id
    "column name"
    userId
}

"placeholder for update columns of table \"affiliation\" (current role has no relevant permissions)"
enum AffiliationUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"select columns of table \"application\""
enum ApplicationSelectColumn {
    "column name"
    id
    "column name"
    name
    "column name"
    topUrl
    "column name"
    validFlag
}

"ordering argument of a cursor"
enum CursorOrdering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"select columns of table \"group_application\""
enum GroupApplicationSelectColumn {
    "column name"
    applicationId
    "column name"
    groupId
    "column name"
    id
}

"select columns of table \"group\""
enum GroupSelectColumn {
    "column name"
    id
    "column name"
    name
}

"unique or primary key constraints on table \"household.account\""
enum HouseholdAccountConstraint {
    "unique or primary key constraint on columns \"id\""
    account_pkey
}

"select columns of table \"household.account\""
enum HouseholdAccountSelectColumn {
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    id
    "column name"
    name
    "column name"
    validFlag
}

"select \"householdAccountAggregateBoolExpBool_andArgumentsColumns\" columns of table \"household.account\""
enum HouseholdAccountSelectColumnHouseholdAccountAggregateBoolExpBool_andArgumentsColumns {
    "column name"
    validFlag
}

"select \"householdAccountAggregateBoolExpBool_orArgumentsColumns\" columns of table \"household.account\""
enum HouseholdAccountSelectColumnHouseholdAccountAggregateBoolExpBool_orArgumentsColumns {
    "column name"
    validFlag
}

"placeholder for update columns of table \"household.account\" (current role has no relevant permissions)"
enum HouseholdAccountUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"select columns of table \"household.all_detail_view\""
enum HouseholdAllDetailViewSelectColumn {
    "column name"
    accountId
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    originalAmount
    "column name"
    signedAmount
    "column name"
    type
}

"unique or primary key constraints on table \"household.category\""
enum HouseholdCategoryConstraint {
    "unique or primary key constraint on columns \"id\""
    category_pkey
}

"select columns of table \"household.category\""
enum HouseholdCategorySelectColumn {
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    name
    "column name"
    validFlag
}

"update columns of table \"household.category\""
enum HouseholdCategoryUpdateColumn {
    "column name"
    displayOrder
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    name
    "column name"
    validFlag
}

"unique or primary key constraints on table \"household.credit_card_detail\""
enum HouseholdCreditCardDetailConstraint {
    "unique or primary key constraint on columns \"id\""
    credit_card_detail_pkey
}

"select columns of table \"household.credit_card_detail\""
enum HouseholdCreditCardDetailSelectColumn {
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    summaryId
    "column name"
    userId
}

"update columns of table \"household.credit_card_detail\""
enum HouseholdCreditCardDetailUpdateColumn {
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    summaryId
    "column name"
    userId
}

"unique or primary key constraints on table \"household.credit_card_summary\""
enum HouseholdCreditCardSummaryConstraint {
    "unique or primary key constraint on columns \"id\""
    credit_card_summary_pkey
}

"select columns of table \"household.credit_card_summary\""
enum HouseholdCreditCardSummarySelectColumn {
    "column name"
    accountId
    "column name"
    count
    "column name"
    creditCard
    "column name"
    groupId
    "column name"
    id
    "column name"
    totalAmount
    "column name"
    withdrawalDate
}

"select columns of table \"household.credit_card_summary_total_by_account_view\""
enum HouseholdCreditCardSummaryTotalByAccountViewSelectColumn {
    "column name"
    accountId
    "column name"
    date
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    name
    "column name"
    total
}

"update columns of table \"household.credit_card_summary\""
enum HouseholdCreditCardSummaryUpdateColumn {
    "column name"
    accountId
    "column name"
    count
    "column name"
    creditCard
    "column name"
    groupId
    "column name"
    id
    "column name"
    totalAmount
    "column name"
    withdrawalDate
}

"unique or primary key constraints on table \"household.daily_detail\""
enum HouseholdDailyDetailConstraint {
    "unique or primary key constraint on columns \"id\""
    daily_detail_pkey
}

"select columns of table \"household.daily_detail\""
enum HouseholdDailyDetailSelectColumn {
    "column name"
    accountId
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    userId
}

"update columns of table \"household.daily_detail\""
enum HouseholdDailyDetailUpdateColumn {
    "column name"
    accountId
    "column name"
    amount
    "column name"
    categoryId
    "column name"
    date
    "column name"
    genreId
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    memo
    "column name"
    userId
}

"select columns of table \"household.daily_total_view\""
enum HouseholdDailyTotalViewSelectColumn {
    "column name"
    date
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"select columns of table \"household.deposit_category\""
enum HouseholdDepositCategorySelectColumn {
    "column name"
    categoryId
    "column name"
    groupId
}

"unique or primary key constraints on table \"household.genre\""
enum HouseholdGenreConstraint {
    "unique or primary key constraint on columns \"id\""
    genre_pkey
}

"select columns of table \"household.genre\""
enum HouseholdGenreSelectColumn {
    "column name"
    displayOrder
    "column name"
    genreType
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    name
    "column name"
    validFlag
}

"select \"householdGenreAggregateBoolExpBool_andArgumentsColumns\" columns of table \"household.genre\""
enum HouseholdGenreSelectColumnHouseholdGenreAggregateBoolExpBool_andArgumentsColumns {
    "column name"
    validFlag
}

"select \"householdGenreAggregateBoolExpBool_orArgumentsColumns\" columns of table \"household.genre\""
enum HouseholdGenreSelectColumnHouseholdGenreAggregateBoolExpBool_orArgumentsColumns {
    "column name"
    validFlag
}

"update columns of table \"household.genre\""
enum HouseholdGenreUpdateColumn {
    "column name"
    displayOrder
    "column name"
    genreType
    "column name"
    groupId
    "column name"
    id
    "column name"
    iocomeType
    "column name"
    name
    "column name"
    validFlag
}

"unique or primary key constraints on table \"household.import_file_history\""
enum HouseholdImportFileHistoryConstraint {
    "unique or primary key constraint on columns \"id\""
    import_file_history_pkey
}

"select columns of table \"household.import_file_history\""
enum HouseholdImportFileHistorySelectColumn {
    "column name"
    fileName
    "column name"
    fileType
    "column name"
    groupId
    "column name"
    id
    "column name"
    importDatetime
    "column name"
    importUserId
}

"placeholder for update columns of table \"household.import_file_history\" (current role has no relevant permissions)"
enum HouseholdImportFileHistoryUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"unique or primary key constraints on table \"household.summary_category\""
enum HouseholdSummaryCategoryConstraint {
    "unique or primary key constraint on columns \"id\""
    summary_category_by_group_pkey
}

"select columns of table \"household.summary_category\""
enum HouseholdSummaryCategorySelectColumn {
    "column name"
    categoryId
    "column name"
    displayOrder
    "column name"
    groupId
    "column name"
    id
}

"placeholder for update columns of table \"household.summary_category\" (current role has no relevant permissions)"
enum HouseholdSummaryCategoryUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

"select columns of table \"household.total_by_category_view\""
enum HouseholdTotalByCategoryViewSelectColumn {
    "column name"
    categoryId
    "column name"
    categoryName
    "column name"
    date
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"select columns of table \"household.total_by_genre_view\""
enum HouseholdTotalByGenreViewSelectColumn {
    "column name"
    date
    "column name"
    genreId
    "column name"
    genreName
    "column name"
    groupId
    "column name"
    iocomeType
    "column name"
    total
}

"select columns of table \"household.transfer_category\""
enum HouseholdTransferCategorySelectColumn {
    "column name"
    groupId
    "column name"
    incomeCategoryId
    "column name"
    outcomeCategoryId
}

"column ordering options"
enum OrderBy {
    "in ascending order, nulls last"
    ASC
    "in ascending order, nulls first"
    ASC_NULLS_FIRST
    "in ascending order, nulls last"
    ASC_NULLS_LAST
    "in descending order, nulls first"
    DESC
    "in descending order, nulls first"
    DESC_NULLS_FIRST
    "in descending order, nulls last"
    DESC_NULLS_LAST
}

"unique or primary key constraints on table \"user\""
enum UserConstraint {
    "unique or primary key constraint on columns \"email\""
    user_email_key
    "unique or primary key constraint on columns \"id\""
    user_pkey
}

"select columns of table \"user\""
enum UserSelectColumn {
    "column name"
    displayOrder
    "column name"
    email
    "column name"
    id
    "column name"
    name
}

"placeholder for update columns of table \"user\" (current role has no relevant permissions)"
enum UserUpdateColumn {
    "placeholder (do not use)"
    _PLACEHOLDER
}

scalar date

scalar numeric

scalar timestamp

input AffiliationAggregateBoolExp {
    count: affiliationAggregateBoolExpCount
}

"order by aggregate values of table \"affiliation\""
input AffiliationAggregateOrderBy {
    count: OrderBy
    max: AffiliationMaxOrderBy
    min: AffiliationMinOrderBy
}

"input type for inserting array relation for remote table \"affiliation\""
input AffiliationArrRelInsertInput {
    data: [AffiliationInsertInput!]!
    "upsert condition"
    onConflict: AffiliationOnConflict
}

"Boolean expression to filter rows from the table \"affiliation\". All fields are combined with a logical 'AND'."
input AffiliationBoolExp {
    _and: [AffiliationBoolExp!]
    _not: AffiliationBoolExp
    _or: [AffiliationBoolExp!]
    group: GroupBoolExp
    groupId: StringComparisonExp
    groupRole: StringComparisonExp
    id: StringComparisonExp
    user: UserBoolExp
    userId: StringComparisonExp
}

"input type for inserting data into table \"affiliation\""
input AffiliationInsertInput {
    groupId: String
    groupRole: String
    id: String
    user: UserObjRelInsertInput
    userId: String
}

"order by max() on columns of table \"affiliation\""
input AffiliationMaxOrderBy {
    groupId: OrderBy
    groupRole: OrderBy
    id: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"affiliation\""
input AffiliationMinOrderBy {
    groupId: OrderBy
    groupRole: OrderBy
    id: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"affiliation\""
input AffiliationOnConflict {
    constraint: AffiliationConstraint!
    updateColumns: [AffiliationUpdateColumn!]! = []
    where: AffiliationBoolExp
}

"Ordering options when selecting data from \"affiliation\"."
input AffiliationOrderBy {
    group: GroupOrderBy
    groupId: OrderBy
    groupRole: OrderBy
    id: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"Streaming cursor of the table \"affiliation\""
input AffiliationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: AffiliationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input AffiliationStreamCursorValueInput {
    groupId: String
    groupRole: String
    id: String
    userId: String
}

"Boolean expression to filter rows from the table \"application\". All fields are combined with a logical 'AND'."
input ApplicationBoolExp {
    _and: [ApplicationBoolExp!]
    _not: ApplicationBoolExp
    _or: [ApplicationBoolExp!]
    groupApplications: GroupApplicationBoolExp
    groupApplicationsAggregate: GroupApplicationAggregateBoolExp
    id: StringComparisonExp
    name: StringComparisonExp
    topUrl: StringComparisonExp
    validFlag: BooleanComparisonExp
}

"Ordering options when selecting data from \"application\"."
input ApplicationOrderBy {
    groupApplicationsAggregate: GroupApplicationAggregateOrderBy
    id: OrderBy
    name: OrderBy
    topUrl: OrderBy
    validFlag: OrderBy
}

"Streaming cursor of the table \"application\""
input ApplicationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: ApplicationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input ApplicationStreamCursorValueInput {
    id: String
    name: String
    topUrl: String
    validFlag: Boolean
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input BooleanComparisonExp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _isNull: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"date\". All fields are combined with logical 'AND'."
input DateComparisonExp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _isNull: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

input GroupApplicationAggregateBoolExp {
    count: groupApplicationAggregateBoolExpCount
}

"order by aggregate values of table \"group_application\""
input GroupApplicationAggregateOrderBy {
    count: OrderBy
    max: GroupApplicationMaxOrderBy
    min: GroupApplicationMinOrderBy
}

"Boolean expression to filter rows from the table \"group_application\". All fields are combined with a logical 'AND'."
input GroupApplicationBoolExp {
    _and: [GroupApplicationBoolExp!]
    _not: GroupApplicationBoolExp
    _or: [GroupApplicationBoolExp!]
    application: ApplicationBoolExp
    applicationId: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
}

"order by max() on columns of table \"group_application\""
input GroupApplicationMaxOrderBy {
    applicationId: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"order by min() on columns of table \"group_application\""
input GroupApplicationMinOrderBy {
    applicationId: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"Ordering options when selecting data from \"group_application\"."
input GroupApplicationOrderBy {
    application: ApplicationOrderBy
    applicationId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
}

"Streaming cursor of the table \"group_application\""
input GroupApplicationStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupApplicationStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupApplicationStreamCursorValueInput {
    applicationId: String
    groupId: String
    id: String
}

"Boolean expression to filter rows from the table \"group\". All fields are combined with a logical 'AND'."
input GroupBoolExp {
    _and: [GroupBoolExp!]
    _not: GroupBoolExp
    _or: [GroupBoolExp!]
    accounts: HouseholdAccountBoolExp
    accountsAggregate: HouseholdAccountAggregateBoolExp
    affiliations: AffiliationBoolExp
    affiliationsAggregate: AffiliationAggregateBoolExp
    categories: HouseholdCategoryBoolExp
    creditCardDetails: HouseholdCreditCardDetailBoolExp
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateBoolExp
    creditCardSummaries: HouseholdCreditCardSummaryBoolExp
    creditCardSummariesAggregate: HouseholdCreditCardSummaryAggregateBoolExp
    dailyDetails: HouseholdDailyDetailBoolExp
    dailyDetailsAggregate: HouseholdDailyDetailAggregateBoolExp
    depositCategories: HouseholdDepositCategoryBoolExp
    depositCategoriesAggregate: HouseholdDepositCategoryAggregateBoolExp
    genres: HouseholdGenreBoolExp
    genresAggregate: HouseholdGenreAggregateBoolExp
    groupApplications: GroupApplicationBoolExp
    groupApplicationsAggregate: GroupApplicationAggregateBoolExp
    id: StringComparisonExp
    importFileHistories: HouseholdImportFileHistoryBoolExp
    importFileHistoriesAggregate: HouseholdImportFileHistoryAggregateBoolExp
    name: StringComparisonExp
    summaryCategories: HouseholdSummaryCategoryBoolExp
    summaryCategoriesAggregate: HouseholdSummaryCategoryAggregateBoolExp
    transferCategory: HouseholdTransferCategoryBoolExp
}

"Ordering options when selecting data from \"group\"."
input GroupOrderBy {
    accountsAggregate: HouseholdAccountAggregateOrderBy
    affiliationsAggregate: AffiliationAggregateOrderBy
    categoriesAggregate: HouseholdCategoryAggregateOrderBy
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateOrderBy
    creditCardSummariesAggregate: HouseholdCreditCardSummaryAggregateOrderBy
    dailyDetailsAggregate: HouseholdDailyDetailAggregateOrderBy
    depositCategoriesAggregate: HouseholdDepositCategoryAggregateOrderBy
    genresAggregate: HouseholdGenreAggregateOrderBy
    groupApplicationsAggregate: GroupApplicationAggregateOrderBy
    id: OrderBy
    importFileHistoriesAggregate: HouseholdImportFileHistoryAggregateOrderBy
    name: OrderBy
    summaryCategoriesAggregate: HouseholdSummaryCategoryAggregateOrderBy
    transferCategory: HouseholdTransferCategoryOrderBy
}

"Streaming cursor of the table \"group\""
input GroupStreamCursorInput {
    "Stream column input with initial value"
    initialValue: GroupStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input GroupStreamCursorValueInput {
    id: String
    name: String
}

input HouseholdAccountAggregateBoolExp {
    bool_and: householdAccountAggregateBoolExpBool_and
    bool_or: householdAccountAggregateBoolExpBool_or
    count: householdAccountAggregateBoolExpCount
}

"order by aggregate values of table \"household.account\""
input HouseholdAccountAggregateOrderBy {
    avg: HouseholdAccountAvgOrderBy
    count: OrderBy
    max: HouseholdAccountMaxOrderBy
    min: HouseholdAccountMinOrderBy
    stddev: HouseholdAccountStddevOrderBy
    stddevPop: HouseholdAccountStddevPopOrderBy
    stddevSamp: HouseholdAccountStddevSampOrderBy
    sum: HouseholdAccountSumOrderBy
    varPop: HouseholdAccountVarPopOrderBy
    varSamp: HouseholdAccountVarSampOrderBy
    variance: HouseholdAccountVarianceOrderBy
}

"order by avg() on columns of table \"household.account\""
input HouseholdAccountAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"household.account\". All fields are combined with a logical 'AND'."
input HouseholdAccountBoolExp {
    _and: [HouseholdAccountBoolExp!]
    _not: HouseholdAccountBoolExp
    _or: [HouseholdAccountBoolExp!]
    allDetailViews: HouseholdAllDetailViewBoolExp
    allDetailViewsAggregate: HouseholdAllDetailViewAggregateBoolExp
    creditCardSummaries: HouseholdCreditCardSummaryBoolExp
    creditCardSummariesAggregate: HouseholdCreditCardSummaryAggregateBoolExp
    dailyDetails: HouseholdDailyDetailBoolExp
    dailyDetailsAggregate: HouseholdDailyDetailAggregateBoolExp
    displayOrder: IntComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    name: StringComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for inserting data into table \"household.account\""
input HouseholdAccountInsertInput {
    creditCardSummaries: HouseholdCreditCardSummaryArrRelInsertInput
    dailyDetails: HouseholdDailyDetailArrRelInsertInput
    displayOrder: Int
    groupId: String
    id: String
    name: String
    validFlag: Boolean
}

"order by max() on columns of table \"household.account\""
input HouseholdAccountMaxOrderBy {
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
    name: OrderBy
}

"order by min() on columns of table \"household.account\""
input HouseholdAccountMinOrderBy {
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
    name: OrderBy
}

"input type for inserting object relation for remote table \"household.account\""
input HouseholdAccountObjRelInsertInput {
    data: HouseholdAccountInsertInput!
    "upsert condition"
    onConflict: HouseholdAccountOnConflict
}

"on_conflict condition type for table \"household.account\""
input HouseholdAccountOnConflict {
    constraint: HouseholdAccountConstraint!
    updateColumns: [HouseholdAccountUpdateColumn!]! = []
    where: HouseholdAccountBoolExp
}

"Ordering options when selecting data from \"household.account\"."
input HouseholdAccountOrderBy {
    allDetailViewsAggregate: HouseholdAllDetailViewAggregateOrderBy
    creditCardSummariesAggregate: HouseholdCreditCardSummaryAggregateOrderBy
    dailyDetailsAggregate: HouseholdDailyDetailAggregateOrderBy
    displayOrder: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    name: OrderBy
    validFlag: OrderBy
}

"order by stddev() on columns of table \"household.account\""
input HouseholdAccountStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"household.account\""
input HouseholdAccountStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"household.account\""
input HouseholdAccountStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"household_account\""
input HouseholdAccountStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdAccountStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdAccountStreamCursorValueInput {
    displayOrder: Int
    groupId: String
    id: String
    name: String
    validFlag: Boolean
}

"order by sum() on columns of table \"household.account\""
input HouseholdAccountSumOrderBy {
    displayOrder: OrderBy
}

"order by varPop() on columns of table \"household.account\""
input HouseholdAccountVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"household.account\""
input HouseholdAccountVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"household.account\""
input HouseholdAccountVarianceOrderBy {
    displayOrder: OrderBy
}

input HouseholdAllDetailViewAggregateBoolExp {
    count: householdAllDetailViewAggregateBoolExpCount
}

"order by aggregate values of table \"household.all_detail_view\""
input HouseholdAllDetailViewAggregateOrderBy {
    avg: HouseholdAllDetailViewAvgOrderBy
    count: OrderBy
    max: HouseholdAllDetailViewMaxOrderBy
    min: HouseholdAllDetailViewMinOrderBy
    stddev: HouseholdAllDetailViewStddevOrderBy
    stddevPop: HouseholdAllDetailViewStddevPopOrderBy
    stddevSamp: HouseholdAllDetailViewStddevSampOrderBy
    sum: HouseholdAllDetailViewSumOrderBy
    varPop: HouseholdAllDetailViewVarPopOrderBy
    varSamp: HouseholdAllDetailViewVarSampOrderBy
    variance: HouseholdAllDetailViewVarianceOrderBy
}

"order by avg() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewAvgOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"Boolean expression to filter rows from the table \"household.all_detail_view\". All fields are combined with a logical 'AND'."
input HouseholdAllDetailViewBoolExp {
    _and: [HouseholdAllDetailViewBoolExp!]
    _not: HouseholdAllDetailViewBoolExp
    _or: [HouseholdAllDetailViewBoolExp!]
    accountId: StringComparisonExp
    categoryId: StringComparisonExp
    date: DateComparisonExp
    genreId: StringComparisonExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    iocomeType: StringComparisonExp
    memo: StringComparisonExp
    originalAmount: NumericComparisonExp
    signedAmount: NumericComparisonExp
    type: StringComparisonExp
}

"order by max() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewMaxOrderBy {
    accountId: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    originalAmount: OrderBy
    signedAmount: OrderBy
    type: OrderBy
}

"order by min() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewMinOrderBy {
    accountId: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    originalAmount: OrderBy
    signedAmount: OrderBy
    type: OrderBy
}

"Ordering options when selecting data from \"household.all_detail_view\"."
input HouseholdAllDetailViewOrderBy {
    accountId: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    originalAmount: OrderBy
    signedAmount: OrderBy
    type: OrderBy
}

"order by stddev() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewStddevOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by stddevPop() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewStddevPopOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by stddevSamp() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewStddevSampOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"Streaming cursor of the table \"household_all_detail_view\""
input HouseholdAllDetailViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdAllDetailViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdAllDetailViewStreamCursorValueInput {
    accountId: String
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    originalAmount: numeric
    signedAmount: numeric
    type: String
}

"order by sum() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewSumOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by varPop() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewVarPopOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by varSamp() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewVarSampOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by variance() on columns of table \"household.all_detail_view\""
input HouseholdAllDetailViewVarianceOrderBy {
    originalAmount: OrderBy
    signedAmount: OrderBy
}

"order by aggregate values of table \"household.category\""
input HouseholdCategoryAggregateOrderBy {
    avg: HouseholdCategoryAvgOrderBy
    count: OrderBy
    max: HouseholdCategoryMaxOrderBy
    min: HouseholdCategoryMinOrderBy
    stddev: HouseholdCategoryStddevOrderBy
    stddevPop: HouseholdCategoryStddevPopOrderBy
    stddevSamp: HouseholdCategoryStddevSampOrderBy
    sum: HouseholdCategorySumOrderBy
    varPop: HouseholdCategoryVarPopOrderBy
    varSamp: HouseholdCategoryVarSampOrderBy
    variance: HouseholdCategoryVarianceOrderBy
}

"input type for inserting array relation for remote table \"household.category\""
input HouseholdCategoryArrRelInsertInput {
    data: [HouseholdCategoryInsertInput!]!
    "upsert condition"
    onConflict: HouseholdCategoryOnConflict
}

"order by avg() on columns of table \"household.category\""
input HouseholdCategoryAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"household.category\". All fields are combined with a logical 'AND'."
input HouseholdCategoryBoolExp {
    _and: [HouseholdCategoryBoolExp!]
    _not: HouseholdCategoryBoolExp
    _or: [HouseholdCategoryBoolExp!]
    creditCardDetails: HouseholdCreditCardDetailBoolExp
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateBoolExp
    dailyDetails: HouseholdDailyDetailBoolExp
    dailyDetailsAggregate: HouseholdDailyDetailAggregateBoolExp
    depositCategory: HouseholdDepositCategoryBoolExp
    displayOrder: IntComparisonExp
    genre: HouseholdGenreBoolExp
    genreId: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    name: StringComparisonExp
    summaryCategories: HouseholdSummaryCategoryBoolExp
    summaryCategoriesAggregate: HouseholdSummaryCategoryAggregateBoolExp
    transferCategories: HouseholdTransferCategoryBoolExp
    transferCategoriesAggregate: HouseholdTransferCategoryAggregateBoolExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"household.category\""
input HouseholdCategoryIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"household.category\""
input HouseholdCategoryInsertInput {
    creditCardDetails: HouseholdCreditCardDetailArrRelInsertInput
    dailyDetails: HouseholdDailyDetailArrRelInsertInput
    displayOrder: Int
    genre: HouseholdGenreObjRelInsertInput
    genreId: String
    groupId: String
    id: String
    name: String
    summaryCategories: HouseholdSummaryCategoryArrRelInsertInput
    validFlag: Boolean
}

"order by max() on columns of table \"household.category\""
input HouseholdCategoryMaxOrderBy {
    displayOrder: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    name: OrderBy
}

"order by min() on columns of table \"household.category\""
input HouseholdCategoryMinOrderBy {
    displayOrder: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    name: OrderBy
}

"input type for inserting object relation for remote table \"household.category\""
input HouseholdCategoryObjRelInsertInput {
    data: HouseholdCategoryInsertInput!
    "upsert condition"
    onConflict: HouseholdCategoryOnConflict
}

"on_conflict condition type for table \"household.category\""
input HouseholdCategoryOnConflict {
    constraint: HouseholdCategoryConstraint!
    updateColumns: [HouseholdCategoryUpdateColumn!]! = []
    where: HouseholdCategoryBoolExp
}

"Ordering options when selecting data from \"household.category\"."
input HouseholdCategoryOrderBy {
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateOrderBy
    dailyDetailsAggregate: HouseholdDailyDetailAggregateOrderBy
    depositCategory: HouseholdDepositCategoryOrderBy
    displayOrder: OrderBy
    genre: HouseholdGenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    name: OrderBy
    summaryCategoriesAggregate: HouseholdSummaryCategoryAggregateOrderBy
    transferCategoriesAggregate: HouseholdTransferCategoryAggregateOrderBy
    validFlag: OrderBy
}

"primary key columns input for table: household.category"
input HouseholdCategoryPkColumnsInput {
    id: String!
}

"input type for updating data in table \"household.category\""
input HouseholdCategorySetInput {
    displayOrder: Int
    genreId: String
    groupId: String
    id: String
    name: String
    validFlag: Boolean
}

"order by stddev() on columns of table \"household.category\""
input HouseholdCategoryStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"household.category\""
input HouseholdCategoryStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"household.category\""
input HouseholdCategoryStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"household_category\""
input HouseholdCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdCategoryStreamCursorValueInput {
    displayOrder: Int
    genreId: String
    groupId: String
    id: String
    name: String
    validFlag: Boolean
}

"order by sum() on columns of table \"household.category\""
input HouseholdCategorySumOrderBy {
    displayOrder: OrderBy
}

input HouseholdCategoryUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HouseholdCategoryIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HouseholdCategorySetInput
    "filter the rows which have to be updated"
    where: HouseholdCategoryBoolExp!
}

"order by varPop() on columns of table \"household.category\""
input HouseholdCategoryVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"household.category\""
input HouseholdCategoryVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"household.category\""
input HouseholdCategoryVarianceOrderBy {
    displayOrder: OrderBy
}

input HouseholdCreditCardDetailAggregateBoolExp {
    count: householdCreditCardDetailAggregateBoolExpCount
}

"order by aggregate values of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailAggregateOrderBy {
    avg: HouseholdCreditCardDetailAvgOrderBy
    count: OrderBy
    max: HouseholdCreditCardDetailMaxOrderBy
    min: HouseholdCreditCardDetailMinOrderBy
    stddev: HouseholdCreditCardDetailStddevOrderBy
    stddevPop: HouseholdCreditCardDetailStddevPopOrderBy
    stddevSamp: HouseholdCreditCardDetailStddevSampOrderBy
    sum: HouseholdCreditCardDetailSumOrderBy
    varPop: HouseholdCreditCardDetailVarPopOrderBy
    varSamp: HouseholdCreditCardDetailVarSampOrderBy
    variance: HouseholdCreditCardDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"household.credit_card_detail\""
input HouseholdCreditCardDetailArrRelInsertInput {
    data: [HouseholdCreditCardDetailInsertInput!]!
    "upsert condition"
    onConflict: HouseholdCreditCardDetailOnConflict
}

"order by avg() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailAvgOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"household.credit_card_detail\". All fields are combined with a logical 'AND'."
input HouseholdCreditCardDetailBoolExp {
    _and: [HouseholdCreditCardDetailBoolExp!]
    _not: HouseholdCreditCardDetailBoolExp
    _or: [HouseholdCreditCardDetailBoolExp!]
    amount: NumericComparisonExp
    category: HouseholdCategoryBoolExp
    categoryId: StringComparisonExp
    creditCardSummary: HouseholdCreditCardSummaryBoolExp
    date: DateComparisonExp
    genre: HouseholdGenreBoolExp
    genreId: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    iocomeType: StringComparisonExp
    memo: StringComparisonExp
    summaryId: StringComparisonExp
    user: UserBoolExp
    userId: StringComparisonExp
}

"input type for incrementing numeric columns in table \"household.credit_card_detail\""
input HouseholdCreditCardDetailIncInput {
    amount: numeric
}

"input type for inserting data into table \"household.credit_card_detail\""
input HouseholdCreditCardDetailInsertInput {
    amount: numeric
    category: HouseholdCategoryObjRelInsertInput
    categoryId: String
    creditCardSummary: HouseholdCreditCardSummaryObjRelInsertInput
    date: date
    genre: HouseholdGenreObjRelInsertInput
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    summaryId: String
    user: UserObjRelInsertInput
    userId: String
}

"order by max() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailMaxOrderBy {
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailMinOrderBy {
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"household.credit_card_detail\""
input HouseholdCreditCardDetailOnConflict {
    constraint: HouseholdCreditCardDetailConstraint!
    updateColumns: [HouseholdCreditCardDetailUpdateColumn!]! = []
    where: HouseholdCreditCardDetailBoolExp
}

"Ordering options when selecting data from \"household.credit_card_detail\"."
input HouseholdCreditCardDetailOrderBy {
    amount: OrderBy
    category: HouseholdCategoryOrderBy
    categoryId: OrderBy
    creditCardSummary: HouseholdCreditCardSummaryOrderBy
    date: OrderBy
    genre: HouseholdGenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    summaryId: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: household.credit_card_detail"
input HouseholdCreditCardDetailPkColumnsInput {
    id: String!
}

"input type for updating data in table \"household.credit_card_detail\""
input HouseholdCreditCardDetailSetInput {
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    summaryId: String
    userId: String
}

"order by stddev() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailStddevOrderBy {
    amount: OrderBy
}

"order by stddevPop() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailStddevPopOrderBy {
    amount: OrderBy
}

"order by stddevSamp() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailStddevSampOrderBy {
    amount: OrderBy
}

"Streaming cursor of the table \"household_credit_card_detail\""
input HouseholdCreditCardDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdCreditCardDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdCreditCardDetailStreamCursorValueInput {
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    summaryId: String
    userId: String
}

"order by sum() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailSumOrderBy {
    amount: OrderBy
}

input HouseholdCreditCardDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HouseholdCreditCardDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HouseholdCreditCardDetailSetInput
    "filter the rows which have to be updated"
    where: HouseholdCreditCardDetailBoolExp!
}

"order by varPop() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailVarPopOrderBy {
    amount: OrderBy
}

"order by varSamp() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailVarSampOrderBy {
    amount: OrderBy
}

"order by variance() on columns of table \"household.credit_card_detail\""
input HouseholdCreditCardDetailVarianceOrderBy {
    amount: OrderBy
}

input HouseholdCreditCardSummaryAggregateBoolExp {
    count: householdCreditCardSummaryAggregateBoolExpCount
}

"order by aggregate values of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryAggregateOrderBy {
    avg: HouseholdCreditCardSummaryAvgOrderBy
    count: OrderBy
    max: HouseholdCreditCardSummaryMaxOrderBy
    min: HouseholdCreditCardSummaryMinOrderBy
    stddev: HouseholdCreditCardSummaryStddevOrderBy
    stddevPop: HouseholdCreditCardSummaryStddevPopOrderBy
    stddevSamp: HouseholdCreditCardSummaryStddevSampOrderBy
    sum: HouseholdCreditCardSummarySumOrderBy
    varPop: HouseholdCreditCardSummaryVarPopOrderBy
    varSamp: HouseholdCreditCardSummaryVarSampOrderBy
    variance: HouseholdCreditCardSummaryVarianceOrderBy
}

"input type for inserting array relation for remote table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryArrRelInsertInput {
    data: [HouseholdCreditCardSummaryInsertInput!]!
    "upsert condition"
    onConflict: HouseholdCreditCardSummaryOnConflict
}

"order by avg() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryAvgOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Boolean expression to filter rows from the table \"household.credit_card_summary\". All fields are combined with a logical 'AND'."
input HouseholdCreditCardSummaryBoolExp {
    _and: [HouseholdCreditCardSummaryBoolExp!]
    _not: HouseholdCreditCardSummaryBoolExp
    _or: [HouseholdCreditCardSummaryBoolExp!]
    account: HouseholdAccountBoolExp
    accountId: StringComparisonExp
    count: IntComparisonExp
    creditCard: StringComparisonExp
    creditCardDetails: HouseholdCreditCardDetailBoolExp
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateBoolExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    totalAmount: NumericComparisonExp
    withdrawalDate: DateComparisonExp
}

"input type for incrementing numeric columns in table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryIncInput {
    count: Int
    totalAmount: numeric
}

"input type for inserting data into table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryInsertInput {
    account: HouseholdAccountObjRelInsertInput
    accountId: String
    count: Int
    creditCard: String
    creditCardDetails: HouseholdCreditCardDetailArrRelInsertInput
    groupId: String
    id: String
    totalAmount: numeric
    withdrawalDate: date
}

"order by max() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryMaxOrderBy {
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"order by min() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryMinOrderBy {
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"input type for inserting object relation for remote table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryObjRelInsertInput {
    data: HouseholdCreditCardSummaryInsertInput!
    "upsert condition"
    onConflict: HouseholdCreditCardSummaryOnConflict
}

"on_conflict condition type for table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryOnConflict {
    constraint: HouseholdCreditCardSummaryConstraint!
    updateColumns: [HouseholdCreditCardSummaryUpdateColumn!]! = []
    where: HouseholdCreditCardSummaryBoolExp
}

"Ordering options when selecting data from \"household.credit_card_summary\"."
input HouseholdCreditCardSummaryOrderBy {
    account: HouseholdAccountOrderBy
    accountId: OrderBy
    count: OrderBy
    creditCard: OrderBy
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateOrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    totalAmount: OrderBy
    withdrawalDate: OrderBy
}

"primary key columns input for table: household.credit_card_summary"
input HouseholdCreditCardSummaryPkColumnsInput {
    id: String!
}

"input type for updating data in table \"household.credit_card_summary\""
input HouseholdCreditCardSummarySetInput {
    accountId: String
    count: Int
    creditCard: String
    groupId: String
    id: String
    totalAmount: numeric
    withdrawalDate: date
}

"order by stddev() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryStddevOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by stddevPop() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryStddevPopOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by stddevSamp() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryStddevSampOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Streaming cursor of the table \"household_credit_card_summary\""
input HouseholdCreditCardSummaryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdCreditCardSummaryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdCreditCardSummaryStreamCursorValueInput {
    accountId: String
    count: Int
    creditCard: String
    groupId: String
    id: String
    totalAmount: numeric
    withdrawalDate: date
}

"order by sum() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummarySumOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"Boolean expression to filter rows from the table \"household.credit_card_summary_total_by_account_view\". All fields are combined with a logical 'AND'."
input HouseholdCreditCardSummaryTotalByAccountViewBoolExp {
    _and: [HouseholdCreditCardSummaryTotalByAccountViewBoolExp!]
    _not: HouseholdCreditCardSummaryTotalByAccountViewBoolExp
    _or: [HouseholdCreditCardSummaryTotalByAccountViewBoolExp!]
    accountId: StringComparisonExp
    date: DateComparisonExp
    displayOrder: IntComparisonExp
    groupId: StringComparisonExp
    iocomeType: StringComparisonExp
    name: StringComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"household.credit_card_summary_total_by_account_view\"."
input HouseholdCreditCardSummaryTotalByAccountViewOrderBy {
    accountId: OrderBy
    date: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    name: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"household_credit_card_summary_total_by_account_view\""
input HouseholdCreditCardSummaryTotalByAccountViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdCreditCardSummaryTotalByAccountViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdCreditCardSummaryTotalByAccountViewStreamCursorValueInput {
    accountId: String
    date: date
    displayOrder: Int
    groupId: String
    iocomeType: String
    name: String
    total: numeric
}

input HouseholdCreditCardSummaryUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HouseholdCreditCardSummaryIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HouseholdCreditCardSummarySetInput
    "filter the rows which have to be updated"
    where: HouseholdCreditCardSummaryBoolExp!
}

"order by varPop() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryVarPopOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by varSamp() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryVarSampOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

"order by variance() on columns of table \"household.credit_card_summary\""
input HouseholdCreditCardSummaryVarianceOrderBy {
    count: OrderBy
    totalAmount: OrderBy
}

input HouseholdDailyDetailAggregateBoolExp {
    count: householdDailyDetailAggregateBoolExpCount
}

"order by aggregate values of table \"household.daily_detail\""
input HouseholdDailyDetailAggregateOrderBy {
    avg: HouseholdDailyDetailAvgOrderBy
    count: OrderBy
    max: HouseholdDailyDetailMaxOrderBy
    min: HouseholdDailyDetailMinOrderBy
    stddev: HouseholdDailyDetailStddevOrderBy
    stddevPop: HouseholdDailyDetailStddevPopOrderBy
    stddevSamp: HouseholdDailyDetailStddevSampOrderBy
    sum: HouseholdDailyDetailSumOrderBy
    varPop: HouseholdDailyDetailVarPopOrderBy
    varSamp: HouseholdDailyDetailVarSampOrderBy
    variance: HouseholdDailyDetailVarianceOrderBy
}

"input type for inserting array relation for remote table \"household.daily_detail\""
input HouseholdDailyDetailArrRelInsertInput {
    data: [HouseholdDailyDetailInsertInput!]!
    "upsert condition"
    onConflict: HouseholdDailyDetailOnConflict
}

"order by avg() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailAvgOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"household.daily_detail\". All fields are combined with a logical 'AND'."
input HouseholdDailyDetailBoolExp {
    _and: [HouseholdDailyDetailBoolExp!]
    _not: HouseholdDailyDetailBoolExp
    _or: [HouseholdDailyDetailBoolExp!]
    account: HouseholdAccountBoolExp
    accountId: StringComparisonExp
    amount: NumericComparisonExp
    category: HouseholdCategoryBoolExp
    categoryId: StringComparisonExp
    date: DateComparisonExp
    genre: HouseholdGenreBoolExp
    genreId: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    iocomeType: StringComparisonExp
    memo: StringComparisonExp
    user: UserBoolExp
    userId: StringComparisonExp
}

"input type for incrementing numeric columns in table \"household.daily_detail\""
input HouseholdDailyDetailIncInput {
    amount: numeric
}

"input type for inserting data into table \"household.daily_detail\""
input HouseholdDailyDetailInsertInput {
    account: HouseholdAccountObjRelInsertInput
    accountId: String
    amount: numeric
    category: HouseholdCategoryObjRelInsertInput
    categoryId: String
    date: date
    genre: HouseholdGenreObjRelInsertInput
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    user: UserObjRelInsertInput
    userId: String
}

"order by max() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailMaxOrderBy {
    accountId: OrderBy
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    userId: OrderBy
}

"order by min() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailMinOrderBy {
    accountId: OrderBy
    amount: OrderBy
    categoryId: OrderBy
    date: OrderBy
    genreId: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    userId: OrderBy
}

"on_conflict condition type for table \"household.daily_detail\""
input HouseholdDailyDetailOnConflict {
    constraint: HouseholdDailyDetailConstraint!
    updateColumns: [HouseholdDailyDetailUpdateColumn!]! = []
    where: HouseholdDailyDetailBoolExp
}

"Ordering options when selecting data from \"household.daily_detail\"."
input HouseholdDailyDetailOrderBy {
    account: HouseholdAccountOrderBy
    accountId: OrderBy
    amount: OrderBy
    category: HouseholdCategoryOrderBy
    categoryId: OrderBy
    date: OrderBy
    genre: HouseholdGenreOrderBy
    genreId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    memo: OrderBy
    user: UserOrderBy
    userId: OrderBy
}

"primary key columns input for table: household.daily_detail"
input HouseholdDailyDetailPkColumnsInput {
    id: String!
}

"input type for updating data in table \"household.daily_detail\""
input HouseholdDailyDetailSetInput {
    accountId: String
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    userId: String
}

"order by stddev() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailStddevOrderBy {
    amount: OrderBy
}

"order by stddevPop() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailStddevPopOrderBy {
    amount: OrderBy
}

"order by stddevSamp() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailStddevSampOrderBy {
    amount: OrderBy
}

"Streaming cursor of the table \"household_daily_detail\""
input HouseholdDailyDetailStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdDailyDetailStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdDailyDetailStreamCursorValueInput {
    accountId: String
    amount: numeric
    categoryId: String
    date: date
    genreId: String
    groupId: String
    id: String
    iocomeType: String
    memo: String
    userId: String
}

"order by sum() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailSumOrderBy {
    amount: OrderBy
}

input HouseholdDailyDetailUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HouseholdDailyDetailIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HouseholdDailyDetailSetInput
    "filter the rows which have to be updated"
    where: HouseholdDailyDetailBoolExp!
}

"order by varPop() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailVarPopOrderBy {
    amount: OrderBy
}

"order by varSamp() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailVarSampOrderBy {
    amount: OrderBy
}

"order by variance() on columns of table \"household.daily_detail\""
input HouseholdDailyDetailVarianceOrderBy {
    amount: OrderBy
}

"Boolean expression to filter rows from the table \"household.daily_total_view\". All fields are combined with a logical 'AND'."
input HouseholdDailyTotalViewBoolExp {
    _and: [HouseholdDailyTotalViewBoolExp!]
    _not: HouseholdDailyTotalViewBoolExp
    _or: [HouseholdDailyTotalViewBoolExp!]
    date: DateComparisonExp
    groupId: StringComparisonExp
    iocomeType: StringComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"household.daily_total_view\"."
input HouseholdDailyTotalViewOrderBy {
    date: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"household_daily_total_view\""
input HouseholdDailyTotalViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdDailyTotalViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdDailyTotalViewStreamCursorValueInput {
    date: date
    groupId: String
    iocomeType: String
    total: numeric
}

input HouseholdDepositCategoryAggregateBoolExp {
    count: householdDepositCategoryAggregateBoolExpCount
}

"order by aggregate values of table \"household.deposit_category\""
input HouseholdDepositCategoryAggregateOrderBy {
    count: OrderBy
    max: HouseholdDepositCategoryMaxOrderBy
    min: HouseholdDepositCategoryMinOrderBy
}

"Boolean expression to filter rows from the table \"household.deposit_category\". All fields are combined with a logical 'AND'."
input HouseholdDepositCategoryBoolExp {
    _and: [HouseholdDepositCategoryBoolExp!]
    _not: HouseholdDepositCategoryBoolExp
    _or: [HouseholdDepositCategoryBoolExp!]
    category: HouseholdCategoryBoolExp
    categoryId: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
}

"order by max() on columns of table \"household.deposit_category\""
input HouseholdDepositCategoryMaxOrderBy {
    categoryId: OrderBy
    groupId: OrderBy
}

"order by min() on columns of table \"household.deposit_category\""
input HouseholdDepositCategoryMinOrderBy {
    categoryId: OrderBy
    groupId: OrderBy
}

"Ordering options when selecting data from \"household.deposit_category\"."
input HouseholdDepositCategoryOrderBy {
    category: HouseholdCategoryOrderBy
    categoryId: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
}

"Streaming cursor of the table \"household_deposit_category\""
input HouseholdDepositCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdDepositCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdDepositCategoryStreamCursorValueInput {
    categoryId: String
    groupId: String
}

input HouseholdGenreAggregateBoolExp {
    bool_and: householdGenreAggregateBoolExpBool_and
    bool_or: householdGenreAggregateBoolExpBool_or
    count: householdGenreAggregateBoolExpCount
}

"order by aggregate values of table \"household.genre\""
input HouseholdGenreAggregateOrderBy {
    avg: HouseholdGenreAvgOrderBy
    count: OrderBy
    max: HouseholdGenreMaxOrderBy
    min: HouseholdGenreMinOrderBy
    stddev: HouseholdGenreStddevOrderBy
    stddevPop: HouseholdGenreStddevPopOrderBy
    stddevSamp: HouseholdGenreStddevSampOrderBy
    sum: HouseholdGenreSumOrderBy
    varPop: HouseholdGenreVarPopOrderBy
    varSamp: HouseholdGenreVarSampOrderBy
    variance: HouseholdGenreVarianceOrderBy
}

"order by avg() on columns of table \"household.genre\""
input HouseholdGenreAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"household.genre\". All fields are combined with a logical 'AND'."
input HouseholdGenreBoolExp {
    _and: [HouseholdGenreBoolExp!]
    _not: HouseholdGenreBoolExp
    _or: [HouseholdGenreBoolExp!]
    categories: HouseholdCategoryBoolExp
    creditCardDetails: HouseholdCreditCardDetailBoolExp
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateBoolExp
    dailyDetails: HouseholdDailyDetailBoolExp
    dailyDetailsAggregate: HouseholdDailyDetailAggregateBoolExp
    displayOrder: IntComparisonExp
    genreType: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    iocomeType: StringComparisonExp
    name: StringComparisonExp
    validFlag: BooleanComparisonExp
}

"input type for incrementing numeric columns in table \"household.genre\""
input HouseholdGenreIncInput {
    displayOrder: Int
}

"input type for inserting data into table \"household.genre\""
input HouseholdGenreInsertInput {
    categories: HouseholdCategoryArrRelInsertInput
    creditCardDetails: HouseholdCreditCardDetailArrRelInsertInput
    dailyDetails: HouseholdDailyDetailArrRelInsertInput
    displayOrder: Int
    genreType: String
    groupId: String
    id: String
    iocomeType: String
    name: String
    validFlag: Boolean
}

"order by max() on columns of table \"household.genre\""
input HouseholdGenreMaxOrderBy {
    displayOrder: OrderBy
    genreType: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    name: OrderBy
}

"order by min() on columns of table \"household.genre\""
input HouseholdGenreMinOrderBy {
    displayOrder: OrderBy
    genreType: OrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    name: OrderBy
}

"input type for inserting object relation for remote table \"household.genre\""
input HouseholdGenreObjRelInsertInput {
    data: HouseholdGenreInsertInput!
    "upsert condition"
    onConflict: HouseholdGenreOnConflict
}

"on_conflict condition type for table \"household.genre\""
input HouseholdGenreOnConflict {
    constraint: HouseholdGenreConstraint!
    updateColumns: [HouseholdGenreUpdateColumn!]! = []
    where: HouseholdGenreBoolExp
}

"Ordering options when selecting data from \"household.genre\"."
input HouseholdGenreOrderBy {
    categoriesAggregate: HouseholdCategoryAggregateOrderBy
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateOrderBy
    dailyDetailsAggregate: HouseholdDailyDetailAggregateOrderBy
    displayOrder: OrderBy
    genreType: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    iocomeType: OrderBy
    name: OrderBy
    validFlag: OrderBy
}

"primary key columns input for table: household.genre"
input HouseholdGenrePkColumnsInput {
    id: String!
}

"input type for updating data in table \"household.genre\""
input HouseholdGenreSetInput {
    displayOrder: Int
    genreType: String
    groupId: String
    id: String
    iocomeType: String
    name: String
    validFlag: Boolean
}

"order by stddev() on columns of table \"household.genre\""
input HouseholdGenreStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"household.genre\""
input HouseholdGenreStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"household.genre\""
input HouseholdGenreStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"household_genre\""
input HouseholdGenreStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdGenreStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdGenreStreamCursorValueInput {
    displayOrder: Int
    genreType: String
    groupId: String
    id: String
    iocomeType: String
    name: String
    validFlag: Boolean
}

"order by sum() on columns of table \"household.genre\""
input HouseholdGenreSumOrderBy {
    displayOrder: OrderBy
}

input HouseholdGenreUpdates {
    "increments the numeric columns with given value of the filtered values"
    _inc: HouseholdGenreIncInput
    "sets the columns of the filtered rows to the given values"
    _set: HouseholdGenreSetInput
    "filter the rows which have to be updated"
    where: HouseholdGenreBoolExp!
}

"order by varPop() on columns of table \"household.genre\""
input HouseholdGenreVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"household.genre\""
input HouseholdGenreVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"household.genre\""
input HouseholdGenreVarianceOrderBy {
    displayOrder: OrderBy
}

input HouseholdImportFileHistoryAggregateBoolExp {
    count: householdImportFileHistoryAggregateBoolExpCount
}

"order by aggregate values of table \"household.import_file_history\""
input HouseholdImportFileHistoryAggregateOrderBy {
    count: OrderBy
    max: HouseholdImportFileHistoryMaxOrderBy
    min: HouseholdImportFileHistoryMinOrderBy
}

"Boolean expression to filter rows from the table \"household.import_file_history\". All fields are combined with a logical 'AND'."
input HouseholdImportFileHistoryBoolExp {
    _and: [HouseholdImportFileHistoryBoolExp!]
    _not: HouseholdImportFileHistoryBoolExp
    _or: [HouseholdImportFileHistoryBoolExp!]
    fileName: StringComparisonExp
    fileType: StringComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
    importDatetime: TimestampComparisonExp
    importUserId: StringComparisonExp
}

"input type for inserting data into table \"household.import_file_history\""
input HouseholdImportFileHistoryInsertInput {
    fileName: String
    fileType: String
    groupId: String
    id: String
    importDatetime: timestamp
    importUserId: String
}

"order by max() on columns of table \"household.import_file_history\""
input HouseholdImportFileHistoryMaxOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"order by min() on columns of table \"household.import_file_history\""
input HouseholdImportFileHistoryMinOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"on_conflict condition type for table \"household.import_file_history\""
input HouseholdImportFileHistoryOnConflict {
    constraint: HouseholdImportFileHistoryConstraint!
    updateColumns: [HouseholdImportFileHistoryUpdateColumn!]! = []
    where: HouseholdImportFileHistoryBoolExp
}

"Ordering options when selecting data from \"household.import_file_history\"."
input HouseholdImportFileHistoryOrderBy {
    fileName: OrderBy
    fileType: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
    importDatetime: OrderBy
    importUserId: OrderBy
}

"Streaming cursor of the table \"household_import_file_history\""
input HouseholdImportFileHistoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdImportFileHistoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdImportFileHistoryStreamCursorValueInput {
    fileName: String
    fileType: String
    groupId: String
    id: String
    importDatetime: timestamp
    importUserId: String
}

input HouseholdSummaryCategoryAggregateBoolExp {
    count: householdSummaryCategoryAggregateBoolExpCount
}

"order by aggregate values of table \"household.summary_category\""
input HouseholdSummaryCategoryAggregateOrderBy {
    avg: HouseholdSummaryCategoryAvgOrderBy
    count: OrderBy
    max: HouseholdSummaryCategoryMaxOrderBy
    min: HouseholdSummaryCategoryMinOrderBy
    stddev: HouseholdSummaryCategoryStddevOrderBy
    stddevPop: HouseholdSummaryCategoryStddevPopOrderBy
    stddevSamp: HouseholdSummaryCategoryStddevSampOrderBy
    sum: HouseholdSummaryCategorySumOrderBy
    varPop: HouseholdSummaryCategoryVarPopOrderBy
    varSamp: HouseholdSummaryCategoryVarSampOrderBy
    variance: HouseholdSummaryCategoryVarianceOrderBy
}

"input type for inserting array relation for remote table \"household.summary_category\""
input HouseholdSummaryCategoryArrRelInsertInput {
    data: [HouseholdSummaryCategoryInsertInput!]!
    "upsert condition"
    onConflict: HouseholdSummaryCategoryOnConflict
}

"order by avg() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryAvgOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"household.summary_category\". All fields are combined with a logical 'AND'."
input HouseholdSummaryCategoryBoolExp {
    _and: [HouseholdSummaryCategoryBoolExp!]
    _not: HouseholdSummaryCategoryBoolExp
    _or: [HouseholdSummaryCategoryBoolExp!]
    category: HouseholdCategoryBoolExp
    categoryId: StringComparisonExp
    displayOrder: IntComparisonExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    id: StringComparisonExp
}

"input type for inserting data into table \"household.summary_category\""
input HouseholdSummaryCategoryInsertInput {
    category: HouseholdCategoryObjRelInsertInput
    categoryId: String
    displayOrder: Int
    groupId: String
    id: String
}

"order by max() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryMaxOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"order by min() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryMinOrderBy {
    categoryId: OrderBy
    displayOrder: OrderBy
    groupId: OrderBy
    id: OrderBy
}

"on_conflict condition type for table \"household.summary_category\""
input HouseholdSummaryCategoryOnConflict {
    constraint: HouseholdSummaryCategoryConstraint!
    updateColumns: [HouseholdSummaryCategoryUpdateColumn!]! = []
    where: HouseholdSummaryCategoryBoolExp
}

"Ordering options when selecting data from \"household.summary_category\"."
input HouseholdSummaryCategoryOrderBy {
    category: HouseholdCategoryOrderBy
    categoryId: OrderBy
    displayOrder: OrderBy
    group: GroupOrderBy
    groupId: OrderBy
    id: OrderBy
}

"order by stddev() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryStddevOrderBy {
    displayOrder: OrderBy
}

"order by stddevPop() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryStddevPopOrderBy {
    displayOrder: OrderBy
}

"order by stddevSamp() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryStddevSampOrderBy {
    displayOrder: OrderBy
}

"Streaming cursor of the table \"household_summary_category\""
input HouseholdSummaryCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdSummaryCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdSummaryCategoryStreamCursorValueInput {
    categoryId: String
    displayOrder: Int
    groupId: String
    id: String
}

"order by sum() on columns of table \"household.summary_category\""
input HouseholdSummaryCategorySumOrderBy {
    displayOrder: OrderBy
}

"order by varPop() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryVarPopOrderBy {
    displayOrder: OrderBy
}

"order by varSamp() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryVarSampOrderBy {
    displayOrder: OrderBy
}

"order by variance() on columns of table \"household.summary_category\""
input HouseholdSummaryCategoryVarianceOrderBy {
    displayOrder: OrderBy
}

"Boolean expression to filter rows from the table \"household.total_by_category_view\". All fields are combined with a logical 'AND'."
input HouseholdTotalByCategoryViewBoolExp {
    _and: [HouseholdTotalByCategoryViewBoolExp!]
    _not: HouseholdTotalByCategoryViewBoolExp
    _or: [HouseholdTotalByCategoryViewBoolExp!]
    categoryId: StringComparisonExp
    categoryName: StringComparisonExp
    date: DateComparisonExp
    genreId: StringComparisonExp
    genreName: StringComparisonExp
    groupId: StringComparisonExp
    iocomeType: StringComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"household.total_by_category_view\"."
input HouseholdTotalByCategoryViewOrderBy {
    categoryId: OrderBy
    categoryName: OrderBy
    date: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"household_total_by_category_view\""
input HouseholdTotalByCategoryViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdTotalByCategoryViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdTotalByCategoryViewStreamCursorValueInput {
    categoryId: String
    categoryName: String
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

"Boolean expression to filter rows from the table \"household.total_by_genre_view\". All fields are combined with a logical 'AND'."
input HouseholdTotalByGenreViewBoolExp {
    _and: [HouseholdTotalByGenreViewBoolExp!]
    _not: HouseholdTotalByGenreViewBoolExp
    _or: [HouseholdTotalByGenreViewBoolExp!]
    date: DateComparisonExp
    genreId: StringComparisonExp
    genreName: StringComparisonExp
    groupId: StringComparisonExp
    iocomeType: StringComparisonExp
    total: NumericComparisonExp
}

"Ordering options when selecting data from \"household.total_by_genre_view\"."
input HouseholdTotalByGenreViewOrderBy {
    date: OrderBy
    genreId: OrderBy
    genreName: OrderBy
    groupId: OrderBy
    iocomeType: OrderBy
    total: OrderBy
}

"Streaming cursor of the table \"household_total_by_genre_view\""
input HouseholdTotalByGenreViewStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdTotalByGenreViewStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdTotalByGenreViewStreamCursorValueInput {
    date: date
    genreId: String
    genreName: String
    groupId: String
    iocomeType: String
    total: numeric
}

input HouseholdTransferCategoryAggregateBoolExp {
    count: householdTransferCategoryAggregateBoolExpCount
}

"order by aggregate values of table \"household.transfer_category\""
input HouseholdTransferCategoryAggregateOrderBy {
    count: OrderBy
    max: HouseholdTransferCategoryMaxOrderBy
    min: HouseholdTransferCategoryMinOrderBy
}

"Boolean expression to filter rows from the table \"household.transfer_category\". All fields are combined with a logical 'AND'."
input HouseholdTransferCategoryBoolExp {
    _and: [HouseholdTransferCategoryBoolExp!]
    _not: HouseholdTransferCategoryBoolExp
    _or: [HouseholdTransferCategoryBoolExp!]
    categoryByIncomeCategoryId: HouseholdCategoryBoolExp
    categoryByOutcomeCategoryId: HouseholdCategoryBoolExp
    group: GroupBoolExp
    groupId: StringComparisonExp
    incomeCategoryId: StringComparisonExp
    outcomeCategoryId: StringComparisonExp
}

"order by max() on columns of table \"household.transfer_category\""
input HouseholdTransferCategoryMaxOrderBy {
    groupId: OrderBy
    incomeCategoryId: OrderBy
    outcomeCategoryId: OrderBy
}

"order by min() on columns of table \"household.transfer_category\""
input HouseholdTransferCategoryMinOrderBy {
    groupId: OrderBy
    incomeCategoryId: OrderBy
    outcomeCategoryId: OrderBy
}

"Ordering options when selecting data from \"household.transfer_category\"."
input HouseholdTransferCategoryOrderBy {
    categoryByIncomeCategoryId: HouseholdCategoryOrderBy
    categoryByOutcomeCategoryId: HouseholdCategoryOrderBy
    group: GroupOrderBy
    groupId: OrderBy
    incomeCategoryId: OrderBy
    outcomeCategoryId: OrderBy
}

"Streaming cursor of the table \"household_transfer_category\""
input HouseholdTransferCategoryStreamCursorInput {
    "Stream column input with initial value"
    initialValue: HouseholdTransferCategoryStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input HouseholdTransferCategoryStreamCursorValueInput {
    groupId: String
    incomeCategoryId: String
    outcomeCategoryId: String
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input IntComparisonExp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _isNull: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input NumericComparisonExp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _isNull: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input StringComparisonExp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _isNull: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input TimestampComparisonExp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _isNull: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to filter rows from the table \"user\". All fields are combined with a logical 'AND'."
input UserBoolExp {
    _and: [UserBoolExp!]
    _not: UserBoolExp
    _or: [UserBoolExp!]
    affiliations: AffiliationBoolExp
    affiliationsAggregate: AffiliationAggregateBoolExp
    creditCardDetails: HouseholdCreditCardDetailBoolExp
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateBoolExp
    dailyDetails: HouseholdDailyDetailBoolExp
    dailyDetailsAggregate: HouseholdDailyDetailAggregateBoolExp
    displayOrder: IntComparisonExp
    email: StringComparisonExp
    id: StringComparisonExp
    name: StringComparisonExp
}

"input type for inserting data into table \"user\""
input UserInsertInput {
    affiliations: AffiliationArrRelInsertInput
    creditCardDetails: HouseholdCreditCardDetailArrRelInsertInput
    dailyDetails: HouseholdDailyDetailArrRelInsertInput
    displayOrder: Int
    email: String
    id: String
    name: String
}

"input type for inserting object relation for remote table \"user\""
input UserObjRelInsertInput {
    data: UserInsertInput!
    "upsert condition"
    onConflict: UserOnConflict
}

"on_conflict condition type for table \"user\""
input UserOnConflict {
    constraint: UserConstraint!
    updateColumns: [UserUpdateColumn!]! = []
    where: UserBoolExp
}

"Ordering options when selecting data from \"user\"."
input UserOrderBy {
    affiliationsAggregate: AffiliationAggregateOrderBy
    creditCardDetailsAggregate: HouseholdCreditCardDetailAggregateOrderBy
    dailyDetailsAggregate: HouseholdDailyDetailAggregateOrderBy
    displayOrder: OrderBy
    email: OrderBy
    id: OrderBy
    name: OrderBy
}

"Streaming cursor of the table \"user\""
input UserStreamCursorInput {
    "Stream column input with initial value"
    initialValue: UserStreamCursorValueInput!
    "cursor ordering"
    ordering: CursorOrdering
}

"Initial value of the column from where the streaming should start"
input UserStreamCursorValueInput {
    displayOrder: Int
    email: String
    id: String
    name: String
}

input affiliationAggregateBoolExpCount {
    arguments: [AffiliationSelectColumn!]
    distinct: Boolean
    filter: AffiliationBoolExp
    predicate: IntComparisonExp!
}

input categoryTotalByMonthArgs {
    from_date: date
    group_id: String
    to_date: date
}

input dailyDetailByDateArgs {
    from_date: date
    group_id: String
    to_date: date
}

input genreTotalByMonthArgs {
    from_date: date
    group_id: String
    to_date: date
}

input groupApplicationAggregateBoolExpCount {
    arguments: [GroupApplicationSelectColumn!]
    distinct: Boolean
    filter: GroupApplicationBoolExp
    predicate: IntComparisonExp!
}

input householdAccountAggregateBoolExpBool_and {
    arguments: HouseholdAccountSelectColumnHouseholdAccountAggregateBoolExpBool_andArgumentsColumns!
    distinct: Boolean
    filter: HouseholdAccountBoolExp
    predicate: BooleanComparisonExp!
}

input householdAccountAggregateBoolExpBool_or {
    arguments: HouseholdAccountSelectColumnHouseholdAccountAggregateBoolExpBool_orArgumentsColumns!
    distinct: Boolean
    filter: HouseholdAccountBoolExp
    predicate: BooleanComparisonExp!
}

input householdAccountAggregateBoolExpCount {
    arguments: [HouseholdAccountSelectColumn!]
    distinct: Boolean
    filter: HouseholdAccountBoolExp
    predicate: IntComparisonExp!
}

input householdAllDetailViewAggregateBoolExpCount {
    arguments: [HouseholdAllDetailViewSelectColumn!]
    distinct: Boolean
    filter: HouseholdAllDetailViewBoolExp
    predicate: IntComparisonExp!
}

input householdCreditCardDetailAggregateBoolExpCount {
    arguments: [HouseholdCreditCardDetailSelectColumn!]
    distinct: Boolean
    filter: HouseholdCreditCardDetailBoolExp
    predicate: IntComparisonExp!
}

input householdCreditCardSummaryAggregateBoolExpCount {
    arguments: [HouseholdCreditCardSummarySelectColumn!]
    distinct: Boolean
    filter: HouseholdCreditCardSummaryBoolExp
    predicate: IntComparisonExp!
}

input householdDailyDetailAggregateBoolExpCount {
    arguments: [HouseholdDailyDetailSelectColumn!]
    distinct: Boolean
    filter: HouseholdDailyDetailBoolExp
    predicate: IntComparisonExp!
}

input householdDepositCategoryAggregateBoolExpCount {
    arguments: [HouseholdDepositCategorySelectColumn!]
    distinct: Boolean
    filter: HouseholdDepositCategoryBoolExp
    predicate: IntComparisonExp!
}

input householdGenreAggregateBoolExpBool_and {
    arguments: HouseholdGenreSelectColumnHouseholdGenreAggregateBoolExpBool_andArgumentsColumns!
    distinct: Boolean
    filter: HouseholdGenreBoolExp
    predicate: BooleanComparisonExp!
}

input householdGenreAggregateBoolExpBool_or {
    arguments: HouseholdGenreSelectColumnHouseholdGenreAggregateBoolExpBool_orArgumentsColumns!
    distinct: Boolean
    filter: HouseholdGenreBoolExp
    predicate: BooleanComparisonExp!
}

input householdGenreAggregateBoolExpCount {
    arguments: [HouseholdGenreSelectColumn!]
    distinct: Boolean
    filter: HouseholdGenreBoolExp
    predicate: IntComparisonExp!
}

input householdImportFileHistoryAggregateBoolExpCount {
    arguments: [HouseholdImportFileHistorySelectColumn!]
    distinct: Boolean
    filter: HouseholdImportFileHistoryBoolExp
    predicate: IntComparisonExp!
}

input householdSummaryCategoryAggregateBoolExpCount {
    arguments: [HouseholdSummaryCategorySelectColumn!]
    distinct: Boolean
    filter: HouseholdSummaryCategoryBoolExp
    predicate: IntComparisonExp!
}

input householdTransferCategoryAggregateBoolExpCount {
    arguments: [HouseholdTransferCategorySelectColumn!]
    distinct: Boolean
    filter: HouseholdTransferCategoryBoolExp
    predicate: IntComparisonExp!
}
